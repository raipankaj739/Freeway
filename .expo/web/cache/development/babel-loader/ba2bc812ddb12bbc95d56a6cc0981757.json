{"ast":null,"code":"import uuidv4 from 'uuid/v4';\nimport { batchResolveAllFontsAsync } from './Fonts.web';\nimport { processAllImagesAsync } from './Images.web';\nimport * as util from './Utils.web';\n\nasync function generateSVGAsync(element, {\n  width,\n  height,\n  bgcolor,\n  style\n} = {}) {\n  const clone = await cloneElement(element);\n\n  if (clone === undefined) {\n    throw new Error('Cannot clone null element');\n  }\n\n  await Promise.all([batchResolveAllFontsAsync(clone), processAllImagesAsync(clone)]);\n\n  if (bgcolor) {\n    clone.style.backgroundColor = bgcolor;\n  }\n\n  if (width) {\n    clone.style.width = `${width}px`;\n  }\n\n  if (height) {\n    clone.style.height = `${height}px`;\n  }\n\n  if (style) {\n    Object.assign(clone.style, style);\n  }\n\n  const svgDataUri = await makeSVGDataURIAsync(clone, width || util.getWidthForElement(element), height || util.getHeightForElement(element));\n  return svgDataUri;\n}\n\nexport async function createSVGAsync(element, options = {}) {\n  return await generateSVGAsync(element, options);\n}\nexport async function createPixelDataAsync(element, options) {\n  const canvas = await draw(element, options);\n  const context = canvas.getContext('2d');\n\n  if (!context) {\n    throw new Error('Canvas context is not supported.');\n  }\n\n  return context.getImageData(0, 0, util.getWidthForElement(element), util.getHeightForElement(element)).data;\n}\nexport async function createPNGAsync(element, options) {\n  const canvas = await draw(element, options);\n  return await canvas.toDataURL('image/png');\n}\nexport async function createJPEGAsync(element, {\n  quality,\n  ...options\n}) {\n  const canvas = await draw(element, options);\n  return await canvas.toDataURL('image/jpeg', quality);\n}\nexport async function createBlobAsync(element, {\n  quality,\n  ...options\n}) {\n  const canvas = await draw(element, options);\n  return await util.getBlobFromCanvasAsync(canvas, quality);\n}\n\nasync function draw(element, options) {\n  const fromSVG = await generateSVGAsync(element, options);\n  const image = await util.getImageElementFromURIAsync(fromSVG);\n  const canvas = newCanvas(element, options);\n  const context = canvas.getContext('2d');\n\n  if (!context) {\n    throw new Error('Canvas context is not supported.');\n  }\n\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n\nfunction newCanvas(element, options) {\n  const canvas = document.createElement('canvas');\n  canvas.width = options.width || util.getWidthForElement(element);\n  canvas.height = options.height || util.getHeightForElement(element);\n\n  if (options.bgcolor) {\n    const ctx = canvas.getContext('2d');\n\n    if (ctx) {\n      ctx.fillStyle = options.bgcolor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n  }\n\n  return canvas;\n}\n\nasync function getDeepCopyForElement(element) {\n  if (element instanceof HTMLCanvasElement) {\n    const dataURL = element.toDataURL();\n    return util.getImageElementFromURIAsync(dataURL);\n  }\n\n  return element.cloneNode(false);\n}\n\nasync function cloneElement(element) {\n  const clonedNode = await getDeepCopyForElement(element);\n  const clone = await cloneChildren(element, clonedNode);\n  return await processClone(element, clone);\n}\n\nasync function cloneChildren({\n  childNodes\n}, clone) {\n  const children = Array.from(childNodes);\n\n  if (children.length === 0) {\n    return clone;\n  }\n\n  for (const child of children) {\n    const childClone = await cloneElement(child);\n\n    if (childClone) {\n      clone.appendChild(childClone);\n    }\n  }\n\n  return clone;\n}\n\nasync function processClone(original, clone) {\n  if (!(clone instanceof HTMLElement)) {\n    // TODO: Bacon: Avoid or throw error\n    return clone;\n  }\n\n  const source = window.getComputedStyle(original);\n  const target = clone.style;\n\n  if (source.cssText) {\n    target.cssText = source.cssText;\n  } else {\n    for (const prop in source) {\n      const name = source[prop];\n      target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n    }\n  }\n\n  clonePseudoElement(':before', original, clone);\n  clonePseudoElement(':after', original, clone);\n  mutateInputElement(original, clone);\n  mutateSVGElementClone(clone);\n  return clone;\n}\n\nfunction clonePseudoElement(element, original, clone) {\n  const style = window.getComputedStyle(original, element);\n  const content = style.getPropertyValue('content');\n\n  if (content === '' || content === 'none') {\n    return;\n  }\n\n  const className = uuidv4();\n  clone.className = `${clone.className} ${className}`;\n  const styleElement = document.createElement('style');\n  styleElement.appendChild(formatPseudoElementStyle(className, element, style));\n  clone.appendChild(styleElement);\n}\n\nfunction formatPseudoElementStyle(className, element, style) {\n  const selector = `.${className}:${element}`;\n  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);\n  return document.createTextNode(`${selector}{${cssText}}`);\n}\n\nfunction formatCSSText(style) {\n  const content = style.getPropertyValue('content');\n  return `${style.cssText} content: ${content};`;\n}\n\nfunction formatCSSProperties(style) {\n  const parsed = Array.from(style).map(name => formatProperty(name, style)).join('; ');\n  return `${parsed};`;\n}\n\nfunction formatProperty(name, style) {\n  return `${name}: ${style.getPropertyValue(name)}${style.getPropertyPriority(name) ? ' !important' : ''}`;\n}\n\nfunction mutateInputElement(element, clone) {\n  if (element instanceof HTMLTextAreaElement) {\n    clone.innerHTML = element.value;\n  }\n\n  if (element instanceof HTMLInputElement) {\n    clone.setAttribute('value', element.value);\n  }\n}\n\nfunction mutateSVGElementClone(element) {\n  if (!(element instanceof SVGElement)) {\n    return;\n  }\n\n  element.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n\n  if (element instanceof SVGRectElement) {\n    for (const attribute of ['width', 'height']) {\n      const value = element.getAttribute(attribute);\n\n      if (!value) {\n        continue;\n      }\n\n      element.style.setProperty(attribute, value);\n    }\n  }\n}\n\nasync function makeSVGDataURIAsync(element, width, height) {\n  element.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n  const serializedNode = new XMLSerializer().serializeToString(element);\n  const xhtml = util.getEscapedXHTMLString(serializedNode);\n  const foreignObject = `<foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${xhtml}</foreignObject>`;\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">${foreignObject}</svg>`;\n  return `data:image/svg+xml;charset=utf-8,${svg}`;\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/Creator.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { CaptureOptions } from 'react-native-view-shot';\nimport uuidv4 from 'uuid/v4';\n\nimport { batchResolveAllFontsAsync } from './Fonts.web';\nimport { processAllImagesAsync } from './Images.web';\nimport * as util from './Utils.web';\n\ntype FillStyle = string | CanvasGradient | CanvasPattern;\n\ninterface SVGOptions {\n  bgcolor?: FillStyle;\n  width?: number;\n  height?: number;\n  style?: any;\n  quality?: number;\n  missingImageSource?: string;\n  preventCaching?: boolean;\n}\n\nasync function generateSVGAsync(\n  element: Element,\n  { width, height, bgcolor, style }: SVGOptions = {}\n): Promise<string> {\n  const clone = await cloneElement(element);\n\n  if (clone === undefined) {\n    throw new Error('Cannot clone null element');\n  }\n\n  await Promise.all([batchResolveAllFontsAsync(clone), processAllImagesAsync(clone)]);\n\n  if (bgcolor) {\n    clone.style.backgroundColor = bgcolor as string;\n  }\n\n  if (width) {\n    clone.style.width = `${width}px`;\n  }\n  if (height) {\n    clone.style.height = `${height}px`;\n  }\n\n  if (style) {\n    Object.assign(clone.style, style);\n  }\n\n  const svgDataUri = await makeSVGDataURIAsync(\n    clone,\n    width || util.getWidthForElement(element),\n    height || util.getHeightForElement(element)\n  );\n  return svgDataUri;\n}\n\nexport async function createSVGAsync(element: Element, options: SVGOptions = {}): Promise<string> {\n  return await generateSVGAsync(element, options);\n}\n\nexport async function createPixelDataAsync(\n  element: Element,\n  options: CaptureOptions\n): Promise<Uint8ClampedArray> {\n  const canvas = await draw(element, options);\n\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('Canvas context is not supported.');\n  }\n\n  return context.getImageData(\n    0,\n    0,\n    util.getWidthForElement(element),\n    util.getHeightForElement(element)\n  ).data;\n}\n\nexport async function createPNGAsync(element: Element, options: CaptureOptions): Promise<string> {\n  const canvas = await draw(element, options);\n  return await canvas.toDataURL('image/png');\n}\n\nexport async function createJPEGAsync(\n  element: Element,\n  { quality, ...options }: CaptureOptions\n): Promise<string> {\n  const canvas = await draw(element, options);\n  return await canvas.toDataURL('image/jpeg', quality);\n}\n\nexport async function createBlobAsync(\n  element: Element,\n  { quality, ...options }: CaptureOptions\n): Promise<Blob> {\n  const canvas = await draw(element, options);\n  return await util.getBlobFromCanvasAsync(canvas, quality);\n}\n\nasync function draw(\n  element: Element,\n  options: {\n    width?: number;\n    height?: number;\n    bgcolor?: string | CanvasGradient | CanvasPattern;\n    [key: string]: any;\n  }\n): Promise<HTMLCanvasElement> {\n  const fromSVG = await generateSVGAsync(element, options);\n  const image = await util.getImageElementFromURIAsync(fromSVG);\n\n  const canvas = newCanvas(element, options);\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('Canvas context is not supported.');\n  }\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n\nfunction newCanvas(\n  element: Element,\n  options: { width?: number; height?: number; bgcolor?: string | CanvasGradient | CanvasPattern }\n) {\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = options.width || util.getWidthForElement(element);\n  canvas.height = options.height || util.getHeightForElement(element);\n\n  if (options.bgcolor) {\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = options.bgcolor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n  }\n\n  return canvas;\n}\n\nasync function getDeepCopyForElement(\n  element: HTMLCanvasElement | Element\n): Promise<HTMLImageElement | Node> {\n  if (element instanceof HTMLCanvasElement) {\n    const dataURL = element.toDataURL();\n    return util.getImageElementFromURIAsync(dataURL);\n  }\n  return element.cloneNode(false);\n}\n\nasync function cloneElement(\n  element: HTMLCanvasElement | Element\n): Promise<HTMLElement | undefined> {\n  const clonedNode = await getDeepCopyForElement(element);\n  const clone = await cloneChildren(element, clonedNode);\n  return await processClone(element, clone as any);\n}\n\nasync function cloneChildren(\n  { childNodes },\n  clone: HTMLImageElement | Node\n): Promise<HTMLElement | Node> {\n  const children: any[] = Array.from(childNodes);\n  if (children.length === 0) {\n    return clone;\n  }\n\n  for (const child of children) {\n    const childClone = await cloneElement(child);\n    if (childClone) {\n      clone.appendChild(childClone);\n    }\n  }\n\n  return clone;\n}\nasync function processClone(original: Element, clone: HTMLElement): Promise<HTMLElement | any> {\n  if (!(clone instanceof HTMLElement)) {\n    // TODO: Bacon: Avoid or throw error\n    return clone;\n  }\n\n  const source = window.getComputedStyle(original);\n  const target = clone.style;\n\n  if (source.cssText) {\n    target.cssText = source.cssText;\n  } else {\n    for (const prop in source) {\n      const name = source[prop];\n      target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n    }\n  }\n\n  clonePseudoElement(':before', original, clone);\n  clonePseudoElement(':after', original, clone);\n  mutateInputElement(original, clone);\n  mutateSVGElementClone(clone);\n  return clone;\n}\n\nfunction clonePseudoElement(element: string, original: Element, clone: HTMLElement): void {\n  const style = window.getComputedStyle(original, element);\n  const content = style.getPropertyValue('content');\n\n  if (content === '' || content === 'none') {\n    return;\n  }\n\n  const className = uuidv4();\n  clone.className = `${clone.className} ${className}`;\n  const styleElement = document.createElement('style');\n  styleElement.appendChild(formatPseudoElementStyle(className, element, style));\n  clone.appendChild(styleElement);\n}\n\nfunction formatPseudoElementStyle(\n  className: string,\n  element: string,\n  style: CSSStyleDeclaration\n): Text {\n  const selector = `.${className}:${element}`;\n  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);\n  return document.createTextNode(`${selector}{${cssText}}`);\n}\n\nfunction formatCSSText(style: CSSStyleDeclaration): string {\n  const content = style.getPropertyValue('content');\n  return `${style.cssText} content: ${content};`;\n}\n\nfunction formatCSSProperties(style: CSSStyleDeclaration): string {\n  const parsed = Array.from(style)\n    .map(name => formatProperty(name, style))\n    .join('; ');\n\n  return `${parsed};`;\n}\n\nfunction formatProperty(name: string, style: CSSStyleDeclaration): string {\n  return `${name}: ${style.getPropertyValue(name)}${\n    style.getPropertyPriority(name) ? ' !important' : ''\n  }`;\n}\n\nfunction mutateInputElement(element: Element, clone: HTMLElement): void {\n  if (element instanceof HTMLTextAreaElement) {\n    clone.innerHTML = element.value;\n  }\n  if (element instanceof HTMLInputElement) {\n    clone.setAttribute('value', element.value);\n  }\n}\n\nfunction mutateSVGElementClone(element: HTMLElement): void {\n  if (!(element instanceof SVGElement)) {\n    return;\n  }\n  element.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n\n  if (element instanceof SVGRectElement) {\n    for (const attribute of ['width', 'height']) {\n      const value = element.getAttribute(attribute);\n      if (!value) {\n        continue;\n      }\n      element.style.setProperty(attribute, value);\n    }\n  }\n}\n\nasync function makeSVGDataURIAsync(\n  element: HTMLElement,\n  width: number,\n  height: number\n): Promise<string> {\n  element.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n\n  const serializedNode: string = new XMLSerializer().serializeToString(element);\n  const xhtml: string = util.getEscapedXHTMLString(serializedNode);\n\n  const foreignObject = `<foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${xhtml}</foreignObject>`;\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">${foreignObject}</svg>`;\n  return `data:image/svg+xml;charset=utf-8,${svg}`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}