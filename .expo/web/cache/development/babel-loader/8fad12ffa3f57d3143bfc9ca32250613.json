{"ast":null,"code":"export default {\n  get name() {\n    return 'ExponentSpeech';\n  },\n\n  async speak(id, text, options) {\n    // @ts-ignore\n    const {\n      SpeechSynthesisUtterance\n    } = global.window;\n    const message = new SpeechSynthesisUtterance();\n\n    if ('rate' in options) {\n      message.rate = options.rate;\n    }\n\n    if ('pitch' in options) {\n      message.pitch = options.pitch;\n    }\n\n    if ('language' in options) {\n      message.lang = options.language;\n    }\n\n    if ('volume' in options) {\n      message.volume = options.volume;\n    }\n\n    if ('_voiceIndex' in options && options._voiceIndex != null) {\n      const voices = window.speechSynthesis.getVoices();\n      message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n    }\n\n    if ('onStart' in options) {\n      message.onstart = options.onStart;\n    }\n\n    if ('onDone' in options) {\n      message.onend = options.onDone;\n    }\n\n    if ('onError' in options) {\n      message.onerror = options.onError;\n    }\n\n    if ('onPause' in options) {\n      message.onpause = options.onPause;\n    }\n\n    if ('onResume' in options) {\n      message.onresume = options.onResume;\n    }\n\n    if ('onMark' in options) {\n      message.onmark = options.onMark;\n    }\n\n    if ('onBoundary' in options) {\n      message.onboundary = options.onBoundary;\n    }\n\n    message.text = text;\n    window.speechSynthesis.speak(message);\n    return message;\n  },\n\n  async isSpeaking() {\n    return window.speechSynthesis.speaking;\n  },\n\n  async stop() {\n    return window.speechSynthesis.cancel();\n  },\n\n  async pause() {\n    return window.speechSynthesis.pause();\n  },\n\n  async resume() {\n    return window.speechSynthesis.resume();\n  }\n\n};","map":{"version":3,"sources":["../src/Speech/ExponentSpeech.web.ts"],"names":[],"mappings":"AAEA,eAAe;AACb,MAAI,IAAJ,GAAQ;AACN,WAAO,gBAAP;AACD,GAHY;;AAIb,QAAM,KAAN,CAAY,EAAZ,EAAwB,IAAxB,EAAsC,OAAtC,EAA4D;AAC1D;AACA,UAAM;AAAE,MAAA;AAAF,QAA+B,MAAM,CAAC,MAA5C;AAEA,UAAM,OAAO,GAAG,IAAI,wBAAJ,EAAhB;;AAEA,QAAI,UAAU,OAAd,EAAuB;AACrB,MAAA,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,IAAvB;AACD;;AACD,QAAI,WAAW,OAAf,EAAwB;AACtB,MAAA,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,KAAxB;AACD;;AACD,QAAI,cAAc,OAAlB,EAA2B;AACzB,MAAA,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,QAAvB;AACD;;AACD,QAAI,YAAY,OAAhB,EAAyB;AACvB,MAAA,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB;AACD;;AACD,QAAI,iBAAiB,OAAjB,IAA4B,OAAO,CAAC,WAAR,IAAuB,IAAvD,EAA6D;AAC3D,YAAM,MAAM,GAAG,MAAM,CAAC,eAAP,CAAuB,SAAvB,EAAf;AACA,MAAA,OAAO,CAAC,KAAR,GAAgB,MAAM,CAAC,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,MAAP,GAAgB,CAAzB,EAA4B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,OAAO,CAAC,WAApB,CAA5B,CAAD,CAAtB;AACD;;AACD,QAAI,aAAa,OAAjB,EAA0B;AACxB,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,QAAI,YAAY,OAAhB,EAAyB;AACvB,MAAA,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,MAAxB;AACD;;AACD,QAAI,aAAa,OAAjB,EAA0B;AACxB,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,QAAI,aAAa,OAAjB,EAA0B;AACxB,MAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,QAAI,cAAc,OAAlB,EAA2B;AACzB,MAAA,OAAO,CAAC,QAAR,GAAmB,OAAO,CAAC,QAA3B;AACD;;AACD,QAAI,YAAY,OAAhB,EAAyB;AACvB,MAAA,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB;AACD;;AACD,QAAI,gBAAgB,OAApB,EAA6B;AAC3B,MAAA,OAAO,CAAC,UAAR,GAAqB,OAAO,CAAC,UAA7B;AACD;;AACD,IAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AACA,IAAA,MAAM,CAAC,eAAP,CAAuB,KAAvB,CAA6B,OAA7B;AAEA,WAAO,OAAP;AACD,GAnDY;;AAoDb,QAAM,UAAN,GAAgB;AACd,WAAO,MAAM,CAAC,eAAP,CAAuB,QAA9B;AACD,GAtDY;;AAuDb,QAAM,IAAN,GAAU;AACR,WAAO,MAAM,CAAC,eAAP,CAAuB,MAAvB,EAAP;AACD,GAzDY;;AA0Db,QAAM,KAAN,GAAW;AACT,WAAO,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAAP;AACD,GA5DY;;AA6Db,QAAM,MAAN,GAAY;AACV,WAAO,MAAM,CAAC,eAAP,CAAuB,MAAvB,EAAP;AACD;;AA/DY,CAAf","sourcesContent":["import { SpeechOptions } from './Speech.types';\n\nexport default {\n  get name(): string {\n    return 'ExponentSpeech';\n  },\n  async speak(id: string, text: string, options: SpeechOptions): Promise<SpeechSynthesisUtterance> {\n    // @ts-ignore\n    const { SpeechSynthesisUtterance } = global.window;\n\n    const message = new SpeechSynthesisUtterance();\n\n    if ('rate' in options) {\n      message.rate = options.rate;\n    }\n    if ('pitch' in options) {\n      message.pitch = options.pitch;\n    }\n    if ('language' in options) {\n      message.lang = options.language;\n    }\n    if ('volume' in options) {\n      message.volume = options.volume;\n    }\n    if ('_voiceIndex' in options && options._voiceIndex != null) {\n      const voices = window.speechSynthesis.getVoices();\n      message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n    }\n    if ('onStart' in options) {\n      message.onstart = options.onStart;\n    }\n    if ('onDone' in options) {\n      message.onend = options.onDone;\n    }\n    if ('onError' in options) {\n      message.onerror = options.onError;\n    }\n    if ('onPause' in options) {\n      message.onpause = options.onPause;\n    }\n    if ('onResume' in options) {\n      message.onresume = options.onResume;\n    }\n    if ('onMark' in options) {\n      message.onmark = options.onMark;\n    }\n    if ('onBoundary' in options) {\n      message.onboundary = options.onBoundary;\n    }\n    message.text = text;\n    window.speechSynthesis.speak(message);\n\n    return message;\n  },\n  async isSpeaking(): Promise<Boolean> {\n    return window.speechSynthesis.speaking;\n  },\n  async stop(): Promise<void> {\n    return window.speechSynthesis.cancel();\n  },\n  async pause(): Promise<void> {\n    return window.speechSynthesis.pause();\n  },\n  async resume(): Promise<void> {\n    return window.speechSynthesis.resume();\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}