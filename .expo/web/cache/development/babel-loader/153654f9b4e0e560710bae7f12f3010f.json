{"ast":null,"code":"import { CodedError } from '@unimodules/core';\nimport { FlipType } from './ImageManipulator.types';\n/**\n * Hermite resize - fast image resize/resample using Hermite filter. 1 cpu version!\n * https://stackoverflow.com/a/18320662/4047926\n *\n * @param {HtmlElement} canvas\n * @param {int} width\n * @param {int} height\n * @param {boolean} resizeCanvas if true, canvas will be resized. Optional.\n */\n\nfunction resampleSingle(canvas, width, height, resizeCanvas = false) {\n  const widthSource = canvas.width;\n  const heightSource = canvas.height;\n  width = Math.round(width);\n  height = Math.round(height);\n  const wRatio = widthSource / width;\n  const hRatio = heightSource / height;\n  const wRatioHalf = Math.ceil(wRatio / 2);\n  const hRatioHalf = Math.ceil(hRatio / 2);\n  let ctx = getContext(canvas);\n  let img = ctx.getImageData(0, 0, widthSource, heightSource);\n  let img2 = ctx.createImageData(width, height);\n  let data = img.data;\n  let data2 = img2.data;\n\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      let x2 = (i + j * width) * 4;\n      let weight = 0;\n      let weights = 0;\n      let weightsAlpha = 0;\n      let gx_r = 0;\n      let gx_g = 0;\n      let gx_b = 0;\n      let gx_a = 0;\n      let yCenter = (j + 0.5) * hRatio;\n      let yy_start = Math.floor(j * hRatio);\n      let yy_stop = Math.ceil((j + 1) * hRatio);\n\n      for (let yy = yy_start; yy < yy_stop; yy++) {\n        let dy = Math.abs(yCenter - (yy + 0.5)) / hRatioHalf;\n        let center_x = (i + 0.5) * wRatio;\n        let w0 = dy * dy; //pre-calc part of w\n\n        let xx_start = Math.floor(i * wRatio);\n        let xx_stop = Math.ceil((i + 1) * wRatio);\n\n        for (let xx = xx_start; xx < xx_stop; xx++) {\n          let dx = Math.abs(center_x - (xx + 0.5)) / wRatioHalf;\n          let w = Math.sqrt(w0 + dx * dx);\n\n          if (w >= 1) {\n            //pixel too far\n            continue;\n          } //hermite filter\n\n\n          weight = 2 * w * w * w - 3 * w * w + 1;\n          let xPosition = 4 * (xx + yy * widthSource); //alpha\n\n          gx_a += weight * data[xPosition + 3];\n          weightsAlpha += weight; //colors\n\n          if (data[xPosition + 3] < 255) {\n            weight = weight * data[xPosition + 3] / 250;\n          }\n\n          gx_r += weight * data[xPosition];\n          gx_g += weight * data[xPosition + 1];\n          gx_b += weight * data[xPosition + 2];\n          weights += weight;\n        }\n      }\n\n      data2[x2] = gx_r / weights;\n      data2[x2 + 1] = gx_g / weights;\n      data2[x2 + 2] = gx_b / weights;\n      data2[x2 + 3] = gx_a / weightsAlpha;\n    }\n  } //clear and resize canvas\n\n\n  if (resizeCanvas) {\n    canvas.width = width;\n    canvas.height = height;\n  } else {\n    ctx.clearRect(0, 0, widthSource, heightSource);\n  } //draw\n\n\n  ctx.putImageData(img2, 0, 0);\n}\n\nfunction sizeFromAngle(width, height, angle) {\n  const radians = angle * Math.PI / 180;\n  let c = Math.cos(radians);\n  let s = Math.sin(radians);\n\n  if (s < 0) {\n    s = -s;\n  }\n\n  if (c < 0) {\n    c = -c;\n  }\n\n  return {\n    width: height * s + width * c,\n    height: height * c + width * s\n  };\n}\n\nfunction cropImage(canvas, image, x = 0, y = 0, width = 0, height = 0) {\n  const context = getContext(canvas);\n  context.save();\n  context.drawImage(image, x, y, width, height, 0, 0, width, height);\n}\n\nfunction drawImage(canvas, img, x = 0, y = 0, angle = 0, xFlip = false, yFlip = false, width, height) {\n  const context = getContext(canvas);\n  context.save();\n\n  if (width == null) {\n    width = img.naturalWidth;\n  }\n\n  if (height == null) {\n    height = img.naturalHeight;\n  } // Set the origin to the center of the image\n\n\n  context.translate(x + canvas.width / 2, y + canvas.height / 2); // Rotate the canvas around the origin\n\n  const radians = 2 * Math.PI - angle * Math.PI / 180;\n  context.rotate(radians); // Flip/flop the canvas\n\n  const xScale = xFlip ? -1 : 1;\n  const yScale = yFlip ? -1 : 1;\n  context.scale(xScale, yScale); // Draw the image\n\n  context.drawImage(img, -img.naturalWidth / 2, -img.naturalHeight / 2, img.naturalWidth, img.naturalHeight);\n  context.restore();\n  return context;\n}\n\nfunction getContext(canvas) {\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    throw new CodedError('ERR_IMAGE_MANIPULATOR', 'Failed to create canvas context');\n  }\n\n  return ctx;\n}\n\nfunction getResults(canvas, options) {\n  let base64;\n\n  if (options) {\n    const {\n      format = 'png'\n    } = options;\n\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n\n    const quality = Math.min(1, Math.max(0, options.compress || 1));\n    base64 = canvas.toDataURL('image/' + format, quality);\n  } else {\n    // defaults to PNG with no loss\n    base64 = canvas.toDataURL();\n  }\n\n  return {\n    uri: base64,\n    width: canvas.width,\n    height: canvas.height,\n    base64\n  };\n}\n\nfunction loadImageAsync(uri) {\n  return new Promise((resolve, reject) => {\n    const imageSource = new Image();\n\n    imageSource.onload = () => resolve(imageSource);\n\n    imageSource.onerror = () => reject(imageSource);\n\n    imageSource.src = uri;\n  });\n}\n\nasync function manipulateWithActionAsync(uri, action, options) {\n  let canvas = document.createElement('canvas');\n  const imageSource = await loadImageAsync(uri);\n  canvas.width = imageSource.naturalWidth;\n  canvas.height = imageSource.naturalHeight;\n\n  if (action.crop) {\n    const {\n      crop\n    } = action; // ensure values are defined.\n\n    let {\n      originX = 0,\n      originY = 0,\n      width = 0,\n      height = 0\n    } = crop;\n\n    const clamp = (value, max) => Math.max(0, Math.min(max, value)); // lock within bounds.\n\n\n    width = clamp(width, canvas.width);\n    height = clamp(height, canvas.height);\n    originX = clamp(originX, canvas.width);\n    originY = clamp(originY, canvas.height); // lock sum of crop.\n\n    width = Math.min(originX + width, canvas.width);\n    height = Math.min(originY + height, canvas.height);\n\n    if (originX - width === 0 || originY - height === 0) {\n      throw new CodedError('ERR_IMAGE_MANIPULATOR_CROP', 'Crop size must be greater than 0: ' + JSON.stringify(crop, null, 2));\n    } // change size of canvas.\n\n\n    canvas.width = width;\n    canvas.height = height;\n    cropImage(canvas, imageSource, originX, originY, width, height);\n  } else if (action.resize) {\n    const {\n      resize\n    } = action;\n    const {\n      width,\n      height\n    } = resize;\n    const imageRatio = imageSource.naturalWidth / imageSource.naturalHeight;\n    let requestedWidth = 0;\n    let requestedHeight = 0;\n\n    if (width !== undefined) {\n      requestedWidth = width;\n      requestedHeight = requestedWidth / imageRatio;\n    }\n\n    if (height !== undefined) {\n      requestedHeight = height;\n\n      if (requestedWidth === 0) {\n        requestedWidth = requestedHeight * imageRatio;\n      }\n    }\n\n    const context = getContext(canvas);\n    context.save();\n    context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n    resampleSingle(canvas, requestedWidth, requestedHeight, true);\n  } else if (action.flip !== undefined) {\n    const {\n      flip\n    } = action;\n    const xFlip = flip === FlipType.Horizontal;\n    const yFlip = flip === FlipType.Vertical;\n    drawImage(canvas, imageSource, 0, 0, 0, xFlip, yFlip);\n  } else if (action.rotate !== undefined) {\n    const {\n      rotate\n    } = action;\n    const {\n      width,\n      height\n    } = sizeFromAngle(imageSource.naturalWidth, imageSource.naturalHeight, rotate);\n    canvas.width = width;\n    canvas.height = height;\n    drawImage(canvas, imageSource, 0, 0, rotate, false, false, width, height);\n  } else {\n    const context = getContext(canvas);\n    context.save();\n    context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n  }\n\n  return getResults(canvas, options);\n}\n\nexport default {\n  get name() {\n    return 'ExpoImageManipulator';\n  },\n\n  async manipulateAsync(uri, actions = [], options) {\n    if (!actions.length) {\n      let canvas = document.createElement('canvas');\n      const imageSource = await loadImageAsync(uri);\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n      const ctx = getContext(canvas);\n      ctx.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n      return getResults(canvas, options);\n    } else {\n      let output;\n\n      for (let i = 0; i < actions.length; i++) {\n        const action = actions[i];\n\n        let _options;\n\n        if (i === actions.length - 1) {\n          _options = options;\n        }\n\n        output = await manipulateWithActionAsync(uri || output.uri, action, _options);\n      }\n\n      return output;\n    }\n  }\n\n};","map":{"version":3,"sources":["../src/ExpoImageManipulator.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\nimport {\n  ImageResult,\n  SaveOptions,\n  Action,\n  ActionCrop,\n  ActionResize,\n  ActionFlip,\n  ActionRotate,\n  FlipType,\n} from './ImageManipulator.types';\n\n/**\n * Hermite resize - fast image resize/resample using Hermite filter. 1 cpu version!\n * https://stackoverflow.com/a/18320662/4047926\n *\n * @param {HtmlElement} canvas\n * @param {int} width\n * @param {int} height\n * @param {boolean} resizeCanvas if true, canvas will be resized. Optional.\n */\nfunction resampleSingle(\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number,\n  resizeCanvas: boolean = false\n): void {\n  const widthSource = canvas.width;\n  const heightSource = canvas.height;\n  width = Math.round(width);\n  height = Math.round(height);\n\n  const wRatio = widthSource / width;\n  const hRatio = heightSource / height;\n  const wRatioHalf = Math.ceil(wRatio / 2);\n  const hRatioHalf = Math.ceil(hRatio / 2);\n\n  let ctx = getContext(canvas);\n\n  let img = ctx.getImageData(0, 0, widthSource, heightSource);\n  let img2 = ctx.createImageData(width, height);\n  let data = img.data;\n  let data2 = img2.data;\n\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      let x2 = (i + j * width) * 4;\n      let weight = 0;\n      let weights = 0;\n      let weightsAlpha = 0;\n      let gx_r = 0;\n      let gx_g = 0;\n      let gx_b = 0;\n      let gx_a = 0;\n      let yCenter = (j + 0.5) * hRatio;\n      let yy_start = Math.floor(j * hRatio);\n      let yy_stop = Math.ceil((j + 1) * hRatio);\n      for (let yy = yy_start; yy < yy_stop; yy++) {\n        let dy = Math.abs(yCenter - (yy + 0.5)) / hRatioHalf;\n        let center_x = (i + 0.5) * wRatio;\n        let w0 = dy * dy; //pre-calc part of w\n        let xx_start = Math.floor(i * wRatio);\n        let xx_stop = Math.ceil((i + 1) * wRatio);\n        for (let xx = xx_start; xx < xx_stop; xx++) {\n          let dx = Math.abs(center_x - (xx + 0.5)) / wRatioHalf;\n          let w = Math.sqrt(w0 + dx * dx);\n          if (w >= 1) {\n            //pixel too far\n            continue;\n          }\n          //hermite filter\n          weight = 2 * w * w * w - 3 * w * w + 1;\n          let xPosition = 4 * (xx + yy * widthSource);\n          //alpha\n          gx_a += weight * data[xPosition + 3];\n          weightsAlpha += weight;\n          //colors\n          if (data[xPosition + 3] < 255) {\n            weight = (weight * data[xPosition + 3]) / 250;\n          }\n          gx_r += weight * data[xPosition];\n          gx_g += weight * data[xPosition + 1];\n          gx_b += weight * data[xPosition + 2];\n          weights += weight;\n        }\n      }\n      data2[x2] = gx_r / weights;\n      data2[x2 + 1] = gx_g / weights;\n      data2[x2 + 2] = gx_b / weights;\n      data2[x2 + 3] = gx_a / weightsAlpha;\n    }\n  }\n  //clear and resize canvas\n  if (resizeCanvas) {\n    canvas.width = width;\n    canvas.height = height;\n  } else {\n    ctx.clearRect(0, 0, widthSource, heightSource);\n  }\n\n  //draw\n  ctx.putImageData(img2, 0, 0);\n}\n\nfunction sizeFromAngle(\n  width: number,\n  height: number,\n  angle: number\n): { width: number; height: number } {\n  const radians = (angle * Math.PI) / 180;\n  let c = Math.cos(radians);\n  let s = Math.sin(radians);\n  if (s < 0) {\n    s = -s;\n  }\n  if (c < 0) {\n    c = -c;\n  }\n  return { width: height * s + width * c, height: height * c + width * s };\n}\n\nfunction cropImage(\n  canvas: HTMLCanvasElement,\n  image: HTMLImageElement,\n  x: number = 0,\n  y: number = 0,\n  width: number = 0,\n  height: number = 0\n): void {\n  const context = getContext(canvas);\n  context.save();\n  context.drawImage(image, x, y, width, height, 0, 0, width, height);\n}\n\nfunction drawImage(\n  canvas: HTMLCanvasElement,\n  img: HTMLImageElement,\n  x: number = 0,\n  y: number = 0,\n  angle: number = 0,\n  xFlip: boolean = false,\n  yFlip: boolean = false,\n  width?: number,\n  height?: number\n): CanvasRenderingContext2D {\n  const context = getContext(canvas);\n  context.save();\n\n  if (width == null) {\n    width = img.naturalWidth as number;\n  }\n  if (height == null) {\n    height = img.naturalHeight as number;\n  }\n\n  // Set the origin to the center of the image\n  context.translate(x + canvas.width / 2, y + canvas.height / 2);\n\n  // Rotate the canvas around the origin\n  const radians = 2 * Math.PI - (angle * Math.PI) / 180;\n  context.rotate(radians);\n\n  // Flip/flop the canvas\n  const xScale = xFlip ? -1 : 1;\n  const yScale = yFlip ? -1 : 1;\n\n  context.scale(xScale, yScale);\n\n  // Draw the image\n  context.drawImage(\n    img,\n    -img.naturalWidth / 2,\n    -img.naturalHeight / 2,\n    img.naturalWidth,\n    img.naturalHeight\n  );\n\n  context.restore();\n  return context;\n}\n\nfunction getContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new CodedError('ERR_IMAGE_MANIPULATOR', 'Failed to create canvas context');\n  }\n  return ctx;\n}\n\nfunction getResults(canvas: HTMLCanvasElement, options?: SaveOptions): ImageResult {\n  let base64;\n  if (options) {\n    const { format = 'png' } = options;\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n    const quality = Math.min(1, Math.max(0, options.compress || 1));\n    base64 = canvas.toDataURL('image/' + format, quality);\n  } else {\n    // defaults to PNG with no loss\n    base64 = canvas.toDataURL();\n  }\n  return {\n    uri: base64,\n    width: canvas.width,\n    height: canvas.height,\n    base64,\n  };\n}\n\nfunction loadImageAsync(uri: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const imageSource = new Image();\n    imageSource.onload = () => resolve(imageSource);\n    imageSource.onerror = () => reject(imageSource);\n    imageSource.src = uri;\n  });\n}\n\nasync function manipulateWithActionAsync(\n  uri: string,\n  action: Action,\n  options: SaveOptions\n): Promise<ImageResult> {\n  let canvas = document.createElement('canvas');\n  const imageSource = await loadImageAsync(uri);\n  canvas.width = imageSource.naturalWidth;\n  canvas.height = imageSource.naturalHeight;\n\n  if ((action as ActionCrop).crop) {\n    const { crop } = action as ActionCrop;\n    // ensure values are defined.\n    let { originX = 0, originY = 0, width = 0, height = 0 } = crop;\n    const clamp = (value, max) => Math.max(0, Math.min(max, value));\n    // lock within bounds.\n    width = clamp(width, canvas.width);\n    height = clamp(height, canvas.height);\n    originX = clamp(originX, canvas.width);\n    originY = clamp(originY, canvas.height);\n\n    // lock sum of crop.\n    width = Math.min(originX + width, canvas.width);\n    height = Math.min(originY + height, canvas.height);\n\n    if (originX - width === 0 || originY - height === 0) {\n      throw new CodedError(\n        'ERR_IMAGE_MANIPULATOR_CROP',\n        'Crop size must be greater than 0: ' + JSON.stringify(crop, null, 2)\n      );\n    }\n\n    // change size of canvas.\n    canvas.width = width;\n    canvas.height = height;\n\n    cropImage(canvas, imageSource, originX, originY, width, height);\n  } else if ((action as ActionResize).resize) {\n    const { resize } = action as ActionResize;\n    const { width, height } = resize;\n\n    const imageRatio = imageSource.naturalWidth / imageSource.naturalHeight;\n\n    let requestedWidth: number = 0;\n    let requestedHeight: number = 0;\n    if (width !== undefined) {\n      requestedWidth = width;\n      requestedHeight = requestedWidth / imageRatio;\n    }\n    if (height !== undefined) {\n      requestedHeight = height;\n      if (requestedWidth === 0) {\n        requestedWidth = requestedHeight * imageRatio;\n      }\n    }\n\n    const context = getContext(canvas);\n    context.save();\n    context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n\n    resampleSingle(canvas, requestedWidth, requestedHeight, true);\n  } else if ((action as ActionFlip).flip !== undefined) {\n    const { flip } = action as ActionFlip;\n    const xFlip = flip === FlipType.Horizontal;\n    const yFlip = flip === FlipType.Vertical;\n    drawImage(canvas, imageSource, 0, 0, 0, xFlip, yFlip);\n  } else if ((action as ActionRotate).rotate !== undefined) {\n    const { rotate } = action as ActionRotate;\n    const { width, height } = sizeFromAngle(\n      imageSource.naturalWidth,\n      imageSource.naturalHeight,\n      rotate\n    );\n    canvas.width = width;\n    canvas.height = height;\n    drawImage(canvas, imageSource, 0, 0, rotate, false, false, width, height);\n  } else {\n    const context = getContext(canvas);\n    context.save();\n    context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n  }\n  return getResults(canvas, options);\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoImageManipulator';\n  },\n  async manipulateAsync(\n    uri: string,\n    actions: Action[] = [],\n    options: SaveOptions\n  ): Promise<ImageResult> {\n    if (!actions.length) {\n      let canvas = document.createElement('canvas');\n      const imageSource = await loadImageAsync(uri);\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n      const ctx = getContext(canvas);\n      ctx.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n      return getResults(canvas, options);\n    } else {\n      let output: ImageResult;\n      for (let i = 0; i < actions.length; i++) {\n        const action = actions[i];\n        let _options;\n        if (i === actions.length - 1) {\n          _options = options;\n        }\n        output = await manipulateWithActionAsync(uri || output!.uri, action, _options);\n      }\n      return output!;\n    }\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}