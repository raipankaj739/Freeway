{"ast":null,"code":"import { PermissionStatus } from './Permissions.types';\nexport function coalesceStatuses(permissions) {\n  const statuses = Object.keys(permissions).map(type => permissions[type].status);\n  statuses.sort((status1, status2) => _getStatusWeight(status1) - _getStatusWeight(status2)); // We choose the \"heaviest\" status with the most implications\n\n  return statuses[statuses.length - 1];\n}\n\nfunction _getStatusWeight(status) {\n  // In terms of weight, we treat UNDETERMINED > DENIED > GRANTED since UNDETERMINED requires the\n  // most amount of further handling (prompting for permission and then checking that permission)\n  // and GRANTED requires the least\n  switch (status) {\n    case PermissionStatus.GRANTED:\n      return 0;\n\n    case PermissionStatus.DENIED:\n      return 1;\n\n    case PermissionStatus.UNDETERMINED:\n      return 2;\n\n    default:\n      return 100;\n  }\n}\n\nexport function coalesceExpirations(permissions) {\n  const maxExpiration = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\n  const expirations = Object.keys(permissions).map(type => permissions[type].expires);\n  expirations.sort((e1, e2) => (e1 == null || e1 === 'never' ? maxExpiration : e1) - (e2 == null || e2 === 'never' ? maxExpiration : e2)); // We choose the earliest expiration\n\n  return expirations[0];\n}","map":{"version":3,"sources":["../src/CoalescedPermissions.ts"],"names":[],"mappings":"AAAA,SAA8C,gBAA9C,QAAsE,qBAAtE;AAEA,OAAM,SAAU,gBAAV,CAA2B,WAA3B,EAAqD;AACzD,QAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,GAAzB,CAA6B,IAAI,IAAI,WAAW,CAAC,IAAD,CAAX,CAAkB,MAAvD,CAAjB;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,CAAC,OAAD,EAAU,OAAV,KAAsB,gBAAgB,CAAC,OAAD,CAAhB,GAA4B,gBAAgB,CAAC,OAAD,CAAhF,EAFyD,CAGzD;;AACA,SAAO,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAnB,CAAf;AACD;;AAED,SAAS,gBAAT,CAA0B,MAA1B,EAAkD;AAChD;AACA;AACA;AACA,UAAQ,MAAR;AACE,SAAK,gBAAgB,CAAC,OAAtB;AACE,aAAO,CAAP;;AACF,SAAK,gBAAgB,CAAC,MAAtB;AACE,aAAO,CAAP;;AACF,SAAK,gBAAgB,CAAC,YAAtB;AACE,aAAO,CAAP;;AACF;AACE,aAAO,GAAP;AARJ;AAUD;;AAED,OAAM,SAAU,mBAAV,CAA8B,WAA9B,EAAwD;AAC5D,QAAM,aAAa,GAAG,gBAAtB,CAD4D,CACpB;;AACxC,QAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,GAAzB,CAA6B,IAAI,IAAI,WAAW,CAAC,IAAD,CAAX,CAAkB,OAAvD,CAApB;AACA,EAAA,WAAW,CAAC,IAAZ,CACE,CAAC,EAAD,EAAK,EAAL,KACE,CAAC,EAAE,IAAI,IAAN,IAAc,EAAE,KAAK,OAArB,GAA+B,aAA/B,GAA+C,EAAhD,KACC,EAAE,IAAI,IAAN,IAAc,EAAE,KAAK,OAArB,GAA+B,aAA/B,GAA+C,EADhD,CAFJ,EAH4D,CAQ5D;;AACA,SAAO,WAAW,CAAC,CAAD,CAAlB;AACD","sourcesContent":["import { PermissionExpiration, PermissionMap, PermissionStatus } from './Permissions.types';\n\nexport function coalesceStatuses(permissions: PermissionMap): PermissionStatus {\n  const statuses = Object.keys(permissions).map(type => permissions[type].status);\n  statuses.sort((status1, status2) => _getStatusWeight(status1) - _getStatusWeight(status2));\n  // We choose the \"heaviest\" status with the most implications\n  return statuses[statuses.length - 1];\n}\n\nfunction _getStatusWeight(status: PermissionStatus): number {\n  // In terms of weight, we treat UNDETERMINED > DENIED > GRANTED since UNDETERMINED requires the\n  // most amount of further handling (prompting for permission and then checking that permission)\n  // and GRANTED requires the least\n  switch (status) {\n    case PermissionStatus.GRANTED:\n      return 0;\n    case PermissionStatus.DENIED:\n      return 1;\n    case PermissionStatus.UNDETERMINED:\n      return 2;\n    default:\n      return 100;\n  }\n}\n\nexport function coalesceExpirations(permissions: PermissionMap): PermissionExpiration {\n  const maxExpiration = 9007199254740991; // Number.MAX_SAFE_INTEGER\n  const expirations = Object.keys(permissions).map(type => permissions[type].expires);\n  expirations.sort(\n    (e1, e2) =>\n      (e1 == null || e1 === 'never' ? maxExpiration : e1) -\n      (e2 == null || e2 === 'never' ? maxExpiration : e2)\n  );\n  // We choose the earliest expiration\n  return expirations[0];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}