{"ast":null,"code":"import { getSourceAndEncodeAsync, formatDataAsUrl, isDataUrl, getMimeTypeFromSource } from './Utils.web';\nimport { batchProcessAllSourcesAsync } from './ProcessSources.web';\nexport async function processAllImagesAsync(element) {\n  if (!(element instanceof HTMLElement)) {\n    return;\n  }\n\n  await processAndMutateNodeBackgroundImageAsync(element);\n\n  if (element instanceof HTMLImageElement) {\n    await loadNewImageAsync(element);\n  } else {\n    const children = Array.from(element.childNodes);\n    await Promise.all(children.map(child => batchProcessAllSourcesAsync(child)));\n  }\n}\n\nasync function processAndMutateNodeBackgroundImageAsync(element) {\n  const background = element.style.getPropertyValue('background');\n\n  if (background) {\n    const backgroundPropertyValue = await batchProcessAllSourcesAsync(background);\n    const currentElementBackgroundPriority = element.style.getPropertyPriority('background');\n    element.style.setProperty('background', backgroundPropertyValue, currentElementBackgroundPriority);\n  }\n}\n\nasync function loadNewImageAsync(element) {\n  if (isDataUrl(element.src)) {\n    return;\n  }\n\n  const data = await getSourceAndEncodeAsync(element.src);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(element.src));\n  return new Promise((resolve, reject) => {\n    element.onload = () => resolve();\n\n    element.onerror = () => {\n      reject(`Image could not be loaded ${element.src}`);\n    };\n\n    element.src = dataUrl;\n  });\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/Images.web.ts"],"names":[],"mappings":"AAAA,SACE,uBADF,EAEE,eAFF,EAGE,SAHF,EAIE,qBAJF,QAKO,aALP;AAOA,SAAS,2BAAT,QAA4C,sBAA5C;AAEA,OAAO,eAAe,qBAAf,CAAqC,OAArC,EAAyD;AAC9D,MAAI,EAAE,OAAO,YAAY,WAArB,CAAJ,EAAuC;AACrC;AACD;;AAED,QAAM,wCAAwC,CAAC,OAAD,CAA9C;;AAEA,MAAI,OAAO,YAAY,gBAAvB,EAAyC;AACvC,UAAM,iBAAiB,CAAC,OAAD,CAAvB;AACD,GAFD,MAEO;AACL,UAAM,QAAQ,GAAU,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,UAAnB,CAAxB;AACA,UAAM,OAAO,CAAC,GAAR,CAAY,QAAQ,CAAC,GAAT,CAAa,KAAK,IAAI,2BAA2B,CAAC,KAAD,CAAjD,CAAZ,CAAN;AACD;AACF;;AAED,eAAe,wCAAf,CAAwD,OAAxD,EAA4E;AAC1E,QAAM,UAAU,GAAG,OAAO,CAAC,KAAR,CAAc,gBAAd,CAA+B,YAA/B,CAAnB;;AACA,MAAI,UAAJ,EAAgB;AACd,UAAM,uBAAuB,GAAG,MAAM,2BAA2B,CAAC,UAAD,CAAjE;AACA,UAAM,gCAAgC,GAAG,OAAO,CAAC,KAAR,CAAc,mBAAd,CAAkC,YAAlC,CAAzC;AACA,IAAA,OAAO,CAAC,KAAR,CAAc,WAAd,CACE,YADF,EAEE,uBAFF,EAGE,gCAHF;AAKD;AACF;;AAED,eAAe,iBAAf,CAAiC,OAAjC,EAA0D;AACxD,MAAI,SAAS,CAAC,OAAO,CAAC,GAAT,CAAb,EAA4B;AAC1B;AACD;;AAED,QAAM,IAAI,GAAG,MAAM,uBAAuB,CAAC,OAAO,CAAC,GAAT,CAA1C;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,IAAD,EAAO,qBAAqB,CAAC,OAAO,CAAC,GAAT,CAA5B,CAA/B;AACA,SAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,IAAA,OAAO,CAAC,MAAR,GAAiB,MAAM,OAAO,EAA9B;;AACA,IAAA,OAAO,CAAC,OAAR,GAAkB,MAAK;AACrB,MAAA,MAAM,CAAC,6BAA6B,OAAO,CAAC,GAAG,EAAzC,CAAN;AACD,KAFD;;AAGA,IAAA,OAAO,CAAC,GAAR,GAAc,OAAd;AACD,GANM,CAAP;AAOD","sourcesContent":["import {\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n  isDataUrl,\n  getMimeTypeFromSource,\n} from './Utils.web';\n\nimport { batchProcessAllSourcesAsync } from './ProcessSources.web';\n\nexport async function processAllImagesAsync(element: HTMLElement): Promise<void> {\n  if (!(element instanceof HTMLElement)) {\n    return;\n  }\n\n  await processAndMutateNodeBackgroundImageAsync(element);\n\n  if (element instanceof HTMLImageElement) {\n    await loadNewImageAsync(element);\n  } else {\n    const children: any[] = Array.from(element.childNodes);\n    await Promise.all(children.map(child => batchProcessAllSourcesAsync(child)));\n  }\n}\n\nasync function processAndMutateNodeBackgroundImageAsync(element: HTMLElement): Promise<void> {\n  const background = element.style.getPropertyValue('background');\n  if (background) {\n    const backgroundPropertyValue = await batchProcessAllSourcesAsync(background);\n    const currentElementBackgroundPriority = element.style.getPropertyPriority('background');\n    element.style.setProperty(\n      'background',\n      backgroundPropertyValue,\n      currentElementBackgroundPriority\n    );\n  }\n}\n\nasync function loadNewImageAsync(element: HTMLImageElement): Promise<any> {\n  if (isDataUrl(element.src)) {\n    return;\n  }\n\n  const data = await getSourceAndEncodeAsync(element.src);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(element.src));\n  return new Promise((resolve, reject) => {\n    element.onload = () => resolve();\n    element.onerror = () => {\n      reject(`Image could not be loaded ${element.src}`);\n    };\n    element.src = dataUrl;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}