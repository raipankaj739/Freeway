{
  "ast": null,
  "code": "import { Asset } from 'expo-asset';\nimport Constants from 'expo-constants';\nimport { Platform } from '@unimodules/core';\nimport ExpoFontLoader from './ExpoFontLoader';\nconst isWeb = Platform.OS === 'web';\nconst loaded = {};\nconst loadPromises = {};\nexport function processFontFamily(name) {\n  if (typeof name !== 'string' || Constants.systemFonts.includes(name) || name === 'System') {\n    return name;\n  }\n\n  if (name.includes(Constants.sessionId)) {\n    return name;\n  }\n\n  if (!isLoaded(name)) {\n    if (__DEV__) {\n      if (isLoading(name)) {\n        console.error(`You started loading the font \"${name}\", but used it before it finished loading.\\n\n- You need to wait for Font.loadAsync to complete before using the font.\\n\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.`);\n      } else {\n        console.error(`fontFamily \"${name}\" is not a system font and has not been loaded through Font.loadAsync.\\n\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\n- If this is a custom font, be sure to load it with Font.loadAsync.`);\n      }\n    }\n\n    return 'System';\n  }\n\n  return `ExpoFont-${_getNativeFontName(name)}`;\n}\nexport function isLoaded(name) {\n  return loaded.hasOwnProperty(name);\n}\nexport function isLoading(name) {\n  return loadPromises.hasOwnProperty(name);\n}\nexport async function loadAsync(nameOrMap, source) {\n  if (typeof nameOrMap === 'object') {\n    const fontMap = nameOrMap;\n    const names = Object.keys(fontMap);\n    await Promise.all(names.map(name => loadAsync(name, fontMap[name])));\n    return;\n  }\n\n  const name = nameOrMap;\n\n  if (loaded[name]) {\n    return;\n  }\n\n  if (loadPromises[name]) {\n    return loadPromises[name];\n  } // Important: we want all callers that concurrently try to load the same font to await the same\n  // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n  // promise in the program, we need to create the promise synchronously without yielding the event\n  // loop from this point.\n\n\n  if (!source) {\n    throw new Error(`No source from which to load font \"${name}\"`);\n  }\n\n  const asset = _getAssetForSource(source);\n\n  loadPromises[name] = (async () => {\n    try {\n      await _loadSingleFontAsync(name, asset);\n      loaded[name] = true;\n    } finally {\n      delete loadPromises[name];\n    }\n  })();\n\n  await loadPromises[name];\n}\n\nfunction _getAssetForSource(source) {\n  if (source instanceof Asset) {\n    return source;\n  }\n\n  if (!isWeb && typeof source === 'string') {\n    return Asset.fromURI(source);\n  }\n\n  if (isWeb || typeof source === 'number') {\n    return Asset.fromModule(source);\n  } // @ts-ignore Error: Type 'string' is not assignable to type 'Asset'\n  // We can't have a string here, we would have thrown an error if !isWeb\n  // or returned Asset.fromModule if isWeb.\n\n\n  return source;\n}\n\nasync function _loadSingleFontAsync(name, asset) {\n  await asset.downloadAsync();\n\n  if (!asset.downloaded) {\n    throw new Error(`Failed to download asset for font \"${name}\"`);\n  }\n\n  await ExpoFontLoader.loadAsync(_getNativeFontName(name), asset.localUri);\n}\n\nfunction _getNativeFontName(name) {\n  if (isWeb) {\n    return name;\n  }\n\n  return `${Constants.sessionId}-${name}`;\n}\n\nif (module && module.exports) {\n  let wasImportWarningShown = false; // @ts-ignore: Temporarily define an export named \"Font\" for legacy compatibility\n\n  Object.defineProperty(exports, 'Font', {\n    get() {\n      if (!wasImportWarningShown) {\n        console.warn(`The syntax \"import { Font } from 'expo-font'\" is deprecated. Use \"import * as Font from 'expo-font'\" or import named exports instead. Support for the old syntax will be removed in SDK 33.`);\n        wasImportWarningShown = true;\n      }\n\n      return {\n        processFontFamily,\n        isLoaded,\n        isLoading,\n        loadAsync\n      };\n    }\n\n  });\n}",
  "map": {
    "version": 3,
    "sources": ["../src/Font.ts"],
    "names": [],
    "mappings": "AAAA,SAAS,KAAT,QAAsB,YAAtB;AACA,OAAO,SAAP,MAAsB,gBAAtB;AACA,SAAS,QAAT,QAAyB,kBAAzB;AAEA,OAAO,cAAP,MAA2B,kBAA3B;AAOA,MAAM,KAAK,GAAG,QAAQ,CAAC,EAAT,KAAgB,KAA9B;AACA,MAAM,MAAM,GAAgC,EAA5C;AACA,MAAM,YAAY,GAAsC,EAAxD;AAEA,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAA+C;AACnD,MAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,SAAS,CAAC,WAAV,CAAsB,QAAtB,CAA+B,IAA/B,CAA5B,IAAoE,IAAI,KAAK,QAAjF,EAA2F;AACzF,WAAO,IAAP;AACD;;AAED,MAAI,IAAI,CAAC,QAAL,CAAc,SAAS,CAAC,SAAxB,CAAJ,EAAwC;AACtC,WAAO,IAAP;AACD;;AAED,MAAI,CAAC,QAAQ,CAAC,IAAD,CAAb,EAAqB;AACnB,QAAI,OAAJ,EAAa;AACX,UAAI,SAAS,CAAC,IAAD,CAAb,EAAqB;AACnB,QAAA,OAAO,CAAC,KAAR,CACE,iCAAiC,IAAI;;qIADvC;AAKD,OAND,MAMO;AACL,QAAA,OAAO,CAAC,KAAR,CACE,eAAe,IAAI;;oEADrB;AAKD;AACF;;AAED,WAAO,QAAP;AACD;;AAED,SAAO,YAAY,kBAAkB,CAAC,IAAD,CAAM,EAA3C;AACD;AAED,OAAM,SAAU,QAAV,CAAmB,IAAnB,EAA+B;AACnC,SAAO,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAgC;AACpC,SAAO,YAAY,CAAC,cAAb,CAA4B,IAA5B,CAAP;AACD;AAED,OAAO,eAAe,SAAf,CACL,SADK,EAEL,MAFK,EAEc;AAEnB,MAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,UAAM,OAAO,GAAG,SAAhB;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAd;AACA,UAAM,OAAO,CAAC,GAAR,CAAY,KAAK,CAAC,GAAN,CAAU,IAAI,IAAI,SAAS,CAAC,IAAD,EAAO,OAAO,CAAC,IAAD,CAAd,CAA3B,CAAZ,CAAN;AACA;AACD;;AAED,QAAM,IAAI,GAAG,SAAb;;AAEA,MAAI,MAAM,CAAC,IAAD,CAAV,EAAkB;AAChB;AACD;;AAED,MAAI,YAAY,CAAC,IAAD,CAAhB,EAAwB;AACtB,WAAO,YAAY,CAAC,IAAD,CAAnB;AACD,GAjBkB,CAmBnB;AACA;AACA;AACA;;;AAEA,MAAI,CAAC,MAAL,EAAa;AACX,UAAM,IAAI,KAAJ,CAAU,sCAAsC,IAAI,GAApD,CAAN;AACD;;AACD,QAAM,KAAK,GAAG,kBAAkB,CAAC,MAAD,CAAhC;;AACA,EAAA,YAAY,CAAC,IAAD,CAAZ,GAAqB,CAAC,YAAW;AAC/B,QAAI;AACF,YAAM,oBAAoB,CAAC,IAAD,EAAO,KAAP,CAA1B;AACA,MAAA,MAAM,CAAC,IAAD,CAAN,GAAe,IAAf;AACD,KAHD,SAGU;AACR,aAAO,YAAY,CAAC,IAAD,CAAnB;AACD;AACF,GAPoB,GAArB;;AASA,QAAM,YAAY,CAAC,IAAD,CAAlB;AACD;;AAED,SAAS,kBAAT,CAA4B,MAA5B,EAA8C;AAC5C,MAAI,MAAM,YAAY,KAAtB,EAA6B;AAC3B,WAAO,MAAP;AACD;;AAED,MAAI,CAAC,KAAD,IAAU,OAAO,MAAP,KAAkB,QAAhC,EAA0C;AACxC,WAAO,KAAK,CAAC,OAAN,CAAc,MAAd,CAAP;AACD;;AAED,MAAI,KAAK,IAAI,OAAO,MAAP,KAAkB,QAA/B,EAAyC;AACvC,WAAO,KAAK,CAAC,UAAN,CAAiB,MAAjB,CAAP;AACD,GAX2C,CAa5C;AACA;AACA;;;AACA,SAAO,MAAP;AACD;;AAED,eAAe,oBAAf,CAAoC,IAApC,EAAkD,KAAlD,EAA8D;AAC5D,QAAM,KAAK,CAAC,aAAN,EAAN;;AACA,MAAI,CAAC,KAAK,CAAC,UAAX,EAAuB;AACrB,UAAM,IAAI,KAAJ,CAAU,sCAAsC,IAAI,GAApD,CAAN;AACD;;AACD,QAAM,cAAc,CAAC,SAAf,CAAyB,kBAAkB,CAAC,IAAD,CAA3C,EAAmD,KAAK,CAAC,QAAzD,CAAN;AACD;;AAED,SAAS,kBAAT,CAA4B,IAA5B,EAAwC;AACtC,MAAI,KAAJ,EAAW;AACT,WAAO,IAAP;AACD;;AACD,SAAO,GAAG,SAAS,CAAC,SAAS,IAAI,IAAI,EAArC;AACD;;AAID,IAAI,MAAM,IAAI,MAAM,CAAC,OAArB,EAA8B;AAC5B,MAAI,qBAAqB,GAAG,KAA5B,CAD4B,CAE5B;;AACA,EAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,EAA+B,MAA/B,EAAuC;AACrC,IAAA,GAAG,GAAA;AACD,UAAI,CAAC,qBAAL,EAA4B;AAC1B,QAAA,OAAO,CAAC,IAAR,CACE,6LADF;AAGA,QAAA,qBAAqB,GAAG,IAAxB;AACD;;AACD,aAAO;AACL,QAAA,iBADK;AAEL,QAAA,QAFK;AAGL,QAAA,SAHK;AAIL,QAAA;AAJK,OAAP;AAMD;;AAdoC,GAAvC;AAgBD",
    "sourcesContent": [
      "import { Asset } from 'expo-asset';\nimport Constants from 'expo-constants';\nimport { Platform } from '@unimodules/core';\n\nimport ExpoFontLoader from './ExpoFontLoader';\n\n/**\n * A font source can be a URI, a module ID, or an Expo Asset.\n */\ntype FontSource = string | number | Asset;\n\nconst isWeb = Platform.OS === 'web';\nconst loaded: { [name: string]: boolean } = {};\nconst loadPromises: { [name: string]: Promise<void> } = {};\n\nexport function processFontFamily(name: string | null): string | null {\n  if (typeof name !== 'string' || Constants.systemFonts.includes(name) || name === 'System') {\n    return name;\n  }\n\n  if (name.includes(Constants.sessionId)) {\n    return name;\n  }\n\n  if (!isLoaded(name)) {\n    if (__DEV__) {\n      if (isLoading(name)) {\n        console.error(\n          `You started loading the font \"${name}\", but used it before it finished loading.\\n\n- You need to wait for Font.loadAsync to complete before using the font.\\n\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.`\n        );\n      } else {\n        console.error(\n          `fontFamily \"${name}\" is not a system font and has not been loaded through Font.loadAsync.\\n\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\n- If this is a custom font, be sure to load it with Font.loadAsync.`\n        );\n      }\n    }\n\n    return 'System';\n  }\n\n  return `ExpoFont-${_getNativeFontName(name)}`;\n}\n\nexport function isLoaded(name: string): boolean {\n  return loaded.hasOwnProperty(name);\n}\n\nexport function isLoading(name: string): boolean {\n  return loadPromises.hasOwnProperty(name);\n}\n\nexport async function loadAsync(\n  nameOrMap: string | { [name: string]: FontSource },\n  source?: FontSource\n): Promise<void> {\n  if (typeof nameOrMap === 'object') {\n    const fontMap = nameOrMap;\n    const names = Object.keys(fontMap);\n    await Promise.all(names.map(name => loadAsync(name, fontMap[name])));\n    return;\n  }\n\n  const name = nameOrMap;\n\n  if (loaded[name]) {\n    return;\n  }\n\n  if (loadPromises[name]) {\n    return loadPromises[name];\n  }\n\n  // Important: we want all callers that concurrently try to load the same font to await the same\n  // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n  // promise in the program, we need to create the promise synchronously without yielding the event\n  // loop from this point.\n\n  if (!source) {\n    throw new Error(`No source from which to load font \"${name}\"`);\n  }\n  const asset = _getAssetForSource(source);\n  loadPromises[name] = (async () => {\n    try {\n      await _loadSingleFontAsync(name, asset);\n      loaded[name] = true;\n    } finally {\n      delete loadPromises[name];\n    }\n  })();\n\n  await loadPromises[name];\n}\n\nfunction _getAssetForSource(source: FontSource): Asset {\n  if (source instanceof Asset) {\n    return source;\n  }\n\n  if (!isWeb && typeof source === 'string') {\n    return Asset.fromURI(source);\n  }\n\n  if (isWeb || typeof source === 'number') {\n    return Asset.fromModule(source);\n  }\n\n  // @ts-ignore Error: Type 'string' is not assignable to type 'Asset'\n  // We can't have a string here, we would have thrown an error if !isWeb\n  // or returned Asset.fromModule if isWeb.\n  return source;\n}\n\nasync function _loadSingleFontAsync(name: string, asset: Asset): Promise<void> {\n  await asset.downloadAsync();\n  if (!asset.downloaded) {\n    throw new Error(`Failed to download asset for font \"${name}\"`);\n  }\n  await ExpoFontLoader.loadAsync(_getNativeFontName(name), asset.localUri);\n}\n\nfunction _getNativeFontName(name: string): string {\n  if (isWeb) {\n    return name;\n  }\n  return `${Constants.sessionId}-${name}`;\n}\n\ndeclare var module: any;\n\nif (module && module.exports) {\n  let wasImportWarningShown = false;\n  // @ts-ignore: Temporarily define an export named \"Font\" for legacy compatibility\n  Object.defineProperty(exports, 'Font', {\n    get() {\n      if (!wasImportWarningShown) {\n        console.warn(\n          `The syntax \"import { Font } from 'expo-font'\" is deprecated. Use \"import * as Font \" or import named exports instead. Support for the old syntax will be removed in SDK 33.`\n        );\n        wasImportWarningShown = true;\n      }\n      return {\n        processFontFamily,\n        isLoaded,\n        isLoading,\n        loadAsync,\n      };\n    },\n  });\n}\n"
    ],
    "sourceRoot": ""
  },
  "metadata": {},
  "sourceType": "module"
}
