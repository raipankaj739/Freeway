{"ast":null,"code":"import { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport ExpoAppAuth from './ExpoAppAuth';\n\nfunction isValidServiceConfiguration(config) {\n  return !!(config && typeof config.authorizationEndpoint === 'string' && typeof config.tokenEndpoint === 'string');\n}\n\nfunction assertValidClientId(clientId) {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`clientId` must be a string with more than 0 characters');\n  }\n}\n\nfunction assertValidProps({\n  issuer,\n  redirectUrl,\n  clientId,\n  serviceConfiguration\n}) {\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', 'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`');\n  }\n\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n\n  assertValidClientId(clientId);\n}\n\nasync function _executeAsync(props) {\n  if (!props.redirectUrl) {\n    props.redirectUrl = getDefaultOAuthRedirect();\n  }\n\n  assertValidProps(props);\n  return await ExpoAppAuth.executeAsync(props);\n}\n\nexport function getDefaultOAuthRedirect() {\n  return `${ExpoAppAuth.OAuthRedirect}:/oauthredirect`;\n}\nexport async function authAsync(props) {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'authAsync');\n  }\n\n  return await _executeAsync(props);\n}\nexport async function refreshAsync(props, refreshToken) {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n  }\n\n  if (!refreshToken) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n  }\n\n  return await _executeAsync({\n    isRefresh: true,\n    refreshToken,\n    ...props\n  });\n}\n/* JS Method */\n\nexport async function revokeAsync({\n  clientId,\n  issuer,\n  serviceConfiguration\n}, {\n  token,\n  isClientIdProvided = false\n}) {\n  if (!token) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n  }\n\n  assertValidClientId(clientId);\n  let revocationEndpoint;\n\n  if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n    revocationEndpoint = serviceConfiguration.revocationEndpoint;\n  } else {\n    // For Open IDC providers only.\n    const response = await fetch(`${issuer}/.well-known/openid-configuration`);\n    const openidConfig = await response.json();\n    invariant(openidConfig.revocation_endpoint, 'The OpenID config does not specify a revocation endpoint');\n    revocationEndpoint = openidConfig.revocation_endpoint;\n  }\n\n  const encodedClientID = encodeURIComponent(clientId);\n  const encodedToken = encodeURIComponent(token);\n  const body = `token=${encodedToken}${isClientIdProvided ? `&client_id=${encodedClientID}` : ''}`;\n  const headers = {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  };\n\n  try {\n    // https://tools.ietf.org/html/rfc7009#section-2.2\n    const results = await fetch(revocationEndpoint, {\n      method: 'POST',\n      headers,\n      body\n    });\n    return results;\n  } catch (error) {\n    throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', error.message);\n  }\n}\n\nasync function parseAuthRevocationResults(results) {\n  const data = await results.json();\n  const token = results.headers['update-client-auth']; // the token has been revoked successfully or the client submitted an invalid token.\n\n  if (results.ok) {\n    // successful op\n    return {\n      type: 'success',\n      status: results.status,\n      data,\n      token\n    };\n  } else if (results.status == 503 && results.headers['retry-after']) {\n    // Failed op\n    const retryAfterValue = results.headers['retry-after'];\n    let retryAfter;\n\n    if (retryAfterValue) {\n      retryAfter = parseRetryTime(retryAfterValue);\n    } // the client must assume the token still exists and may retry after a reasonable delay.\n\n\n    return {\n      type: 'failed',\n      status: results.status,\n      data,\n      token,\n      retryAfter\n    };\n  } else {\n    // Error\n    return {\n      type: 'error',\n      status: results.status,\n      data,\n      token\n    };\n  }\n}\n\nfunction parseRetryTime(value) {\n  // In accordance with RFC2616, Section 14.37. Timout may be of format seconds or future date time value\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n\n  const retry = Date.parse(value);\n\n  if (isNaN(retry)) {\n    throw new CodedError('ERR_APP_AUTH_FETCH_RETRY_TIME', 'Cannot parse the Retry-After header value returned by the server: ' + value);\n  }\n\n  const now = Date.now();\n  const parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nexport const {\n  OAuthRedirect,\n  URLSchemes\n} = ExpoAppAuth;","map":{"version":3,"sources":["../src/AppAuth.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport {\n  OAuthBaseProps,\n  OAuthProps,\n  OAuthRevokeOptions,\n  OAuthServiceConfiguration,\n  TokenResponse,\n} from './AppAuth.types';\nimport ExpoAppAuth from './ExpoAppAuth';\n\nexport * from './AppAuth.types';\n\nfunction isValidServiceConfiguration(config?: OAuthServiceConfiguration): boolean {\n  return !!(\n    config &&\n    typeof config.authorizationEndpoint === 'string' &&\n    typeof config.tokenEndpoint === 'string'\n  );\n}\n\nfunction assertValidClientId(clientId?: string): void {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      '`clientId` must be a string with more than 0 characters'\n    );\n  }\n}\n\nfunction assertValidProps({\n  issuer,\n  redirectUrl,\n  clientId,\n  serviceConfiguration,\n}: OAuthProps): void {\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`'\n    );\n  }\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n  assertValidClientId(clientId);\n}\n\nasync function _executeAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!props.redirectUrl) {\n    props.redirectUrl = getDefaultOAuthRedirect();\n  }\n  assertValidProps(props);\n  return await ExpoAppAuth.executeAsync(props);\n}\n\nexport function getDefaultOAuthRedirect(): string {\n  return `${ExpoAppAuth.OAuthRedirect}:/oauthredirect`;\n}\n\nexport async function authAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'authAsync');\n  }\n  return await _executeAsync(props);\n}\n\nexport async function refreshAsync(\n  props: OAuthProps,\n  refreshToken: string\n): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n  }\n  if (!refreshToken) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n  }\n  return await _executeAsync({\n    isRefresh: true,\n    refreshToken,\n    ...props,\n  });\n}\n\n/* JS Method */\nexport async function revokeAsync(\n  { clientId, issuer, serviceConfiguration }: OAuthBaseProps,\n  { token, isClientIdProvided = false }: OAuthRevokeOptions\n): Promise<any> {\n  if (!token) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n  }\n\n  assertValidClientId(clientId);\n\n  let revocationEndpoint;\n  if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n    revocationEndpoint = serviceConfiguration.revocationEndpoint;\n  } else {\n    // For Open IDC providers only.\n    const response = await fetch(`${issuer}/.well-known/openid-configuration`);\n    const openidConfig = await response.json();\n\n    invariant(\n      openidConfig.revocation_endpoint,\n      'The OpenID config does not specify a revocation endpoint'\n    );\n\n    revocationEndpoint = openidConfig.revocation_endpoint;\n  }\n\n  const encodedClientID = encodeURIComponent(clientId);\n  const encodedToken = encodeURIComponent(token);\n  const body = `token=${encodedToken}${isClientIdProvided ? `&client_id=${encodedClientID}` : ''}`;\n  const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n  try {\n    // https://tools.ietf.org/html/rfc7009#section-2.2\n    const results = await fetch(revocationEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n\n    return results;\n  } catch (error) {\n    throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', error.message);\n  }\n}\n\nasync function parseAuthRevocationResults(results: Response): Promise<any> {\n  const data = await results.json();\n  const token = results.headers['update-client-auth'];\n  // the token has been revoked successfully or the client submitted an invalid token.\n  if (results.ok) {\n    // successful op\n    return { type: 'success', status: results.status, data, token };\n  } else if (results.status == 503 && results.headers['retry-after']) {\n    // Failed op\n    const retryAfterValue = results.headers['retry-after'];\n    let retryAfter: number | undefined;\n    if (retryAfterValue) {\n      retryAfter = parseRetryTime(retryAfterValue);\n    }\n    // the client must assume the token still exists and may retry after a reasonable delay.\n    return { type: 'failed', status: results.status, data, token, retryAfter };\n  } else {\n    // Error\n    return { type: 'error', status: results.status, data, token };\n  }\n}\n\nfunction parseRetryTime(value: string): number {\n  // In accordance with RFC2616, Section 14.37. Timout may be of format seconds or future date time value\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n  const retry = Date.parse(value);\n  if (isNaN(retry)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_FETCH_RETRY_TIME',\n      'Cannot parse the Retry-After header value returned by the server: ' + value\n    );\n  }\n  const now = Date.now();\n  const parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nexport const { OAuthRedirect, URLSchemes } = ExpoAppAuth;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}