{"ast":null,"code":"import { EventEmitter } from '@unimodules/core';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoTaskManager from './ExpoTaskManager';\nconst eventEmitter = new EventEmitter(ExpoTaskManager);\nconst tasks = new Map();\nlet isRunningDuringInitialization = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\nexport function defineTask(taskName, task) {\n  if (!isRunningDuringInitialization) {\n    console.error(`TaskManager.defineTask must be called during initialization phase!`);\n    return;\n  }\n\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n\n  if (!task || typeof task !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n\n  if (tasks.has(taskName)) {\n    console.warn(`TaskManager.defineTask: task '${taskName}' is already defined.`);\n    return;\n  }\n\n  tasks.set(taskName, task);\n}\nexport function isTaskDefined(taskName) {\n  return tasks.has(taskName);\n}\nexport async function isTaskRegisteredAsync(taskName) {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n  }\n\n  _validateTaskName(taskName);\n\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\nexport async function getTaskOptionsAsync(taskName) {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n  }\n\n  _validateTaskName(taskName);\n\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\nexport async function getRegisteredTasksAsync() {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\nexport async function unregisterTaskAsync(taskName) {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n  }\n\n  _validateTaskName(taskName);\n\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\nexport async function unregisterAllTasksAsync() {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\neventEmitter.addListener(ExpoTaskManager.EVENT_NAME, async ({\n  data,\n  error,\n  executionInfo\n}) => {\n  const {\n    eventId,\n    taskName\n  } = executionInfo;\n  const task = tasks.get(taskName);\n  let result = null;\n\n  if (task) {\n    try {\n      // Execute JS task\n      result = await task({\n        data,\n        error,\n        executionInfo\n      });\n    } catch (error) {\n      console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n    } finally {\n      // Notify manager the task is finished.\n      await ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n        eventId,\n        result\n      });\n    }\n  } else {\n    console.warn(`TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`); // No tasks defined -> we need to notify about finish anyway.\n\n    await ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n      eventId,\n      result\n    }); // We should also unregister such tasks automatically as the task might have been removed\n    // from the app or just renamed - in that case it needs to be registered again (with the new name).\n\n    await ExpoTaskManager.unregisterTaskAsync(taskName);\n  }\n}); // @tsapeta: Turn off `defineTask` function right after the initialization phase.\n// Promise.resolve() ensures that it will be called as a microtask just after the first event loop.\n\nPromise.resolve().then(() => {\n  isRunningDuringInitialization = false;\n});","map":{"version":3,"sources":["../src/TaskManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from '@unimodules/core';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoTaskManager from './ExpoTaskManager';\n\ninterface TaskError {\n  code: string | number,\n  message: string,\n}\n\ninterface TaskBody {\n  data: object,\n  error: TaskError | null,\n  executionInfo: {\n    eventId: string,\n    taskName: string,\n  },\n}\n\nexport interface RegisteredTask {\n  taskName: string,\n  taskType: string,\n  options: any,\n}\n\ntype Task = (body: TaskBody) => void;\n\nconst eventEmitter = new EventEmitter(ExpoTaskManager);\nconst tasks: Map<string, Task> = new Map<string, Task>();\n\nlet isRunningDuringInitialization = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.')\n  }\n}\n\nexport function defineTask(taskName: string, task: Task) {\n  if (!isRunningDuringInitialization) {\n    console.error(`TaskManager.defineTask must be called during initialization phase!`);\n    return;\n  }\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!task || typeof task !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  if (tasks.has(taskName)) {\n    console.warn(`TaskManager.defineTask: task '${taskName}' is already defined.`);\n    return;\n  }\n  tasks.set(taskName, task);\n}\n\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\nexport async function getRegisteredTasksAsync(): Promise<RegisteredTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync')\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync')\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync')\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\neventEmitter.addListener<TaskBody>(ExpoTaskManager.EVENT_NAME, async ({ data, error, executionInfo }) => {\n  const { eventId, taskName } = executionInfo;\n  const task = tasks.get(taskName);\n  let result: any = null;\n\n  if (task) {\n    try {\n      // Execute JS task\n      result = await task({ data, error, executionInfo });\n    } catch (error) {\n      console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n    } finally {\n      // Notify manager the task is finished.\n      await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n    }\n  } else {\n    console.warn(`TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`);\n    // No tasks defined -> we need to notify about finish anyway.\n    await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n    // We should also unregister such tasks automatically as the task might have been removed\n    // from the app or just renamed - in that case it needs to be registered again (with the new name).\n    await ExpoTaskManager.unregisterTaskAsync(taskName);\n  }\n});\n\n// @tsapeta: Turn off `defineTask` function right after the initialization phase.\n// Promise.resolve() ensures that it will be called as a microtask just after the first event loop.\nPromise.resolve().then(() => {\n  isRunningDuringInitialization = false;\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}