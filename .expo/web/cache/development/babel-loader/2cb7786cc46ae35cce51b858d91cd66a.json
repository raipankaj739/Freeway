{"ast":null,"code":"import { Platform } from '@unimodules/core';\nimport * as FileSystem from 'expo-file-system';\nimport Constants from 'expo-constants';\nimport computeMd5 from 'blueimp-md5';\nimport { getAssetByID } from './AssetRegistry';\nimport resolveAssetSource, { setCustomSourceTransformer } from './resolveAssetSource';\nimport * as AssetSources from './AssetSources';\nimport * as AssetUris from './AssetUris';\nimport * as EmbeddedAssets from './EmbeddedAssets';\nimport * as ImageAssets from './ImageAssets';\nconst IS_MANAGED_ENV = !!Constants.appOwnership;\nexport class Asset {\n  constructor({\n    name,\n    type,\n    hash = null,\n    uri,\n    width,\n    height\n  }) {\n    this.hash = null;\n    this.localUri = null;\n    this.width = null;\n    this.height = null;\n    this.downloading = false;\n    this.downloaded = false;\n    this._downloadCallbacks = [];\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n\n    if (typeof height === 'number') {\n      this.height = height;\n    } // This only applies to assets that are bundled in Expo standalone apps\n\n\n    if (IS_MANAGED_ENV && hash) {\n      this.localUri = EmbeddedAssets.getEmbeddedAssetUri(hash, type);\n\n      if (this.localUri) {\n        this.downloaded = true;\n      }\n    }\n  }\n\n  static loadAsync(moduleId) {\n    const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n    return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule) {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    }\n\n    const meta = getAssetByID(virtualAssetModule);\n\n    if (!meta) {\n      throw new Error(`Module \"${virtualAssetModule}\" is missing from the asset registry`);\n    } // Outside of the managed env we need the moduleId to initialize the asset\n    // because resolveAssetSource depends on it\n\n\n    if (!IS_MANAGED_ENV) {\n      const {\n        uri\n      } = resolveAssetSource(virtualAssetModule);\n      const asset = new Asset({\n        name: meta.name,\n        type: meta.type,\n        hash: meta.hash,\n        uri,\n        width: meta.width,\n        height: meta.height\n      }); // TODO: FileSystem should probably support 'downloading' from drawable\n      // resources But for now it doesn't (it only supports raw resources) and\n      // React Native's Image works fine with drawable resource names for\n      // images.\n\n      if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n        asset.localUri = asset.uri;\n        asset.downloaded = true;\n      }\n\n      Asset.byHash[meta.hash] = asset;\n      return asset;\n    }\n\n    return Asset.fromMetadata(meta);\n  }\n\n  static fromMetadata(meta) {\n    // The hash of the whole asset, not to be confused with the hash of a specific file returned\n    // from `selectAssetSource`\n    const metaHash = meta.hash;\n\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    } else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n      throw new Error('Assets must be initialized with Asset.fromModule');\n    }\n\n    const {\n      uri,\n      hash\n    } = AssetSources.selectAssetSource(meta);\n    const asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri) {\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    } // Possibly a Base64-encoded URI\n\n\n    let type = '';\n\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      const extension = AssetUris.getFileExtension(uri);\n      type = extension.startsWith('.') ? extension.substring(1) : extension;\n    }\n\n    const asset = new Asset({\n      name: '',\n      type,\n      hash: null,\n      uri\n    });\n    Asset.byUri[uri] = asset;\n    return asset;\n  }\n\n  async _downloadAsyncWeb() {\n    if (ImageAssets.isImageType(this.type)) {\n      const {\n        width,\n        height,\n        name\n      } = await ImageAssets.getImageInfoAsync(this.uri);\n      this.width = width;\n      this.height = height;\n      this.name = name;\n    } else {\n      this.name = AssetUris.getFilename(this.uri);\n    }\n\n    this.localUri = this.uri;\n  }\n\n  async _downloadAsyncManagedEnv() {\n    const cacheFileId = this.hash || computeMd5(this.uri);\n    const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`;\n    let {\n      exists,\n      md5\n    } = await FileSystem.getInfoAsync(localUri, {\n      md5: true\n    });\n\n    if (!exists || this.hash !== null && md5 !== this.hash) {\n      ({\n        md5\n      } = await FileSystem.downloadAsync(this.uri, localUri, {\n        md5: true\n      }));\n\n      if (this.hash !== null && md5 !== this.hash) {\n        throw new Error(`Downloaded file for asset '${this.name}.${this.type}' ` + `Located at ${this.uri} ` + `failed MD5 integrity check`);\n      }\n    }\n\n    this.localUri = localUri;\n  }\n\n  async _downloadAsyncUnmanagedEnv() {\n    // Bail out if it's already at a file URL because it's already available locally\n    if (this.uri.startsWith('file://')) {\n      this.localUri = this.uri;\n      return;\n    }\n\n    const cacheFileId = this.hash || computeMd5(this.uri);\n    const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`; // We don't check the FileSystem for an existing version of the asset and we\n    // also don't perform an integrity check!\n\n    await FileSystem.downloadAsync(this.uri, localUri);\n    this.localUri = localUri;\n  }\n\n  async downloadAsync() {\n    if (this.downloaded) {\n      return;\n    }\n\n    if (this.downloading) {\n      await new Promise((resolve, reject) => {\n        this._downloadCallbacks.push({\n          resolve,\n          reject\n        });\n      });\n      return;\n    }\n\n    this.downloading = true;\n\n    try {\n      if (Platform.OS === 'web') {\n        await this._downloadAsyncWeb();\n      } else if (IS_MANAGED_ENV) {\n        await this._downloadAsyncManagedEnv();\n      } else {\n        await this._downloadAsyncUnmanagedEnv();\n      }\n\n      this.downloaded = true;\n\n      this._downloadCallbacks.forEach(({\n        resolve\n      }) => resolve());\n    } catch (e) {\n      this._downloadCallbacks.forEach(({\n        reject\n      }) => reject(e));\n\n      throw e;\n    } finally {\n      this.downloading = false;\n      this._downloadCallbacks = [];\n    }\n  }\n\n}\nAsset.byHash = {};\nAsset.byUri = {}; // Override React Native's asset resolution for `Image` components\n\nsetCustomSourceTransformer(resolver => {\n  try {\n    const asset = Asset.fromMetadata(resolver.asset);\n    return resolver.fromSource(asset.downloaded ? asset.localUri : asset.uri);\n  } catch (e) {\n    return resolver.defaultAsset();\n  }\n});","map":{"version":3,"sources":["../src/Asset.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport * as FileSystem from 'expo-file-system';\nimport Constants from 'expo-constants';\nimport computeMd5 from 'blueimp-md5';\nimport { getAssetByID } from './AssetRegistry';\nimport resolveAssetSource, { setCustomSourceTransformer } from './resolveAssetSource';\n\nimport * as AssetSources from './AssetSources';\nimport * as AssetUris from './AssetUris';\nimport * as EmbeddedAssets from './EmbeddedAssets';\nimport * as ImageAssets from './ImageAssets';\n\ntype AssetDescriptor = {\n  name: string;\n  type: string;\n  hash?: string | null;\n  uri: string;\n  width?: number | null;\n  height?: number | null;\n};\n\ntype DownloadPromiseCallbacks = {\n  resolve: () => void;\n  reject: (error: Error) => void;\n};\n\nexport type AssetMetadata = AssetSources.AssetMetadata;\n\nconst IS_MANAGED_ENV = !!Constants.appOwnership;\n\nexport class Asset {\n  static byHash = {};\n  static byUri = {};\n\n  name: string;\n  type: string;\n  hash: string | null = null;\n  uri: string;\n  localUri: string | null = null;\n  width: number | null = null;\n  height: number | null = null;\n  downloading: boolean = false;\n  downloaded: boolean = false;\n  _downloadCallbacks: DownloadPromiseCallbacks[] = [];\n\n  constructor({ name, type, hash = null, uri, width, height }: AssetDescriptor) {\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n    if (typeof height === 'number') {\n      this.height = height;\n    }\n\n    // This only applies to assets that are bundled in Expo standalone apps\n    if (IS_MANAGED_ENV && hash) {\n      this.localUri = EmbeddedAssets.getEmbeddedAssetUri(hash, type);\n      if (this.localUri) {\n        this.downloaded = true;\n      }\n    }\n  }\n\n  static loadAsync(moduleId: number | number[]): Promise<void[]> {\n    const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n    return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule: number | string): Asset {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    }\n\n    const meta = getAssetByID(virtualAssetModule);\n    if (!meta) {\n      throw new Error(`Module \"${virtualAssetModule}\" is missing from the asset registry`);\n    }\n\n    // Outside of the managed env we need the moduleId to initialize the asset\n    // because resolveAssetSource depends on it\n    if (!IS_MANAGED_ENV) {\n      const { uri } = resolveAssetSource(virtualAssetModule);\n      const asset = new Asset({\n        name: meta.name,\n        type: meta.type,\n        hash: meta.hash,\n        uri,\n        width: meta.width,\n        height: meta.height,\n      });\n\n      // TODO: FileSystem should probably support 'downloading' from drawable\n      // resources But for now it doesn't (it only supports raw resources) and\n      // React Native's Image works fine with drawable resource names for\n      // images.\n      if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n        asset.localUri = asset.uri;\n        asset.downloaded = true;\n      }\n\n      Asset.byHash[meta.hash] = asset;\n      return asset;\n    }\n\n    return Asset.fromMetadata(meta);\n  }\n\n  static fromMetadata(meta: AssetMetadata): Asset {\n    // The hash of the whole asset, not to be confused with the hash of a specific file returned\n    // from `selectAssetSource`\n    const metaHash = meta.hash;\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    } else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n      throw new Error('Assets must be initialized with Asset.fromModule');\n    }\n\n    const { uri, hash } = AssetSources.selectAssetSource(meta);\n    const asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height,\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri: string): Asset {\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    }\n\n    // Possibly a Base64-encoded URI\n    let type = '';\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      const extension = AssetUris.getFileExtension(uri);\n      type = extension.startsWith('.') ? extension.substring(1) : extension;\n    }\n\n    const asset = new Asset({\n      name: '',\n      type,\n      hash: null,\n      uri,\n    });\n\n    Asset.byUri[uri] = asset;\n\n    return asset;\n  }\n\n  async _downloadAsyncWeb(): Promise<void> {\n    if (ImageAssets.isImageType(this.type)) {\n      const { width, height, name } = await ImageAssets.getImageInfoAsync(this.uri);\n      this.width = width;\n      this.height = height;\n      this.name = name;\n    } else {\n      this.name = AssetUris.getFilename(this.uri);\n    }\n    this.localUri = this.uri;\n  }\n\n  async _downloadAsyncManagedEnv(): Promise<void> {\n    const cacheFileId = this.hash || computeMd5(this.uri);\n    const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`;\n    let { exists, md5 } = await FileSystem.getInfoAsync(localUri, {\n      md5: true,\n    });\n    if (!exists || (this.hash !== null && md5 !== this.hash)) {\n      ({ md5 } = await FileSystem.downloadAsync(this.uri, localUri, {\n        md5: true,\n      }));\n      if (this.hash !== null && md5 !== this.hash) {\n        throw new Error(\n          `Downloaded file for asset '${this.name}.${this.type}' ` +\n            `Located at ${this.uri} ` +\n            `failed MD5 integrity check`\n        );\n      }\n    }\n\n    this.localUri = localUri;\n  }\n\n  async _downloadAsyncUnmanagedEnv(): Promise<void> {\n    // Bail out if it's already at a file URL because it's already available locally\n    if (this.uri.startsWith('file://')) {\n      this.localUri = this.uri;\n      return;\n    }\n\n    const cacheFileId = this.hash || computeMd5(this.uri);\n    const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`;\n    // We don't check the FileSystem for an existing version of the asset and we\n    // also don't perform an integrity check!\n    await FileSystem.downloadAsync(this.uri, localUri);\n    this.localUri = localUri;\n  }\n\n  async downloadAsync(): Promise<void> {\n    if (this.downloaded) {\n      return;\n    }\n    if (this.downloading) {\n      await new Promise((resolve, reject) => {\n        this._downloadCallbacks.push({ resolve, reject });\n      });\n      return;\n    }\n    this.downloading = true;\n\n    try {\n      if (Platform.OS === 'web') {\n        await this._downloadAsyncWeb();\n      } else if (IS_MANAGED_ENV) {\n        await this._downloadAsyncManagedEnv();\n      } else {\n        await this._downloadAsyncUnmanagedEnv();\n      }\n\n      this.downloaded = true;\n      this._downloadCallbacks.forEach(({ resolve }) => resolve());\n    } catch (e) {\n      this._downloadCallbacks.forEach(({ reject }) => reject(e));\n      throw e;\n    } finally {\n      this.downloading = false;\n      this._downloadCallbacks = [];\n    }\n  }\n}\n\n// Override React Native's asset resolution for `Image` components\nsetCustomSourceTransformer(resolver => {\n  try {\n    const asset = Asset.fromMetadata(resolver.asset);\n    return resolver.fromSource(asset.downloaded ? asset.localUri! : asset.uri);\n  } catch (e) {\n    return resolver.defaultAsset();\n  }\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}