{"ast":null,"code":"import { isDataUrl, getMimeTypeFromSource, getEscapedString, resolveUrl, getSourceAndEncodeAsync, formatDataAsUrl } from './Utils.web';\nconst URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\nexport function shouldProcess(string) {\n  if (!string.search) {\n    return false;\n  }\n\n  return string.search(URL_REGEX) !== -1;\n}\nexport async function batchProcessAllSourcesAsync(string, baseUrl, get) {\n  if (!shouldProcess(string)) {\n    return string;\n  }\n\n  const urls = readURLs(string);\n  let done = Promise.resolve(string);\n\n  for (const url of urls) {\n    done = done.then(string => processURLAsync(string, url, baseUrl, get));\n  }\n\n  return done;\n}\n\nfunction readURLs(urls) {\n  const result = [];\n  let match;\n\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n\n  return result.filter(url => !isDataUrl(url));\n}\n\nasync function processURLAsync(string, url, baseUrl = undefined, getSourceAsync = getSourceAndEncodeAsync) {\n  const finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n  const data = await getSourceAsync(finalURL);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n  return string.replace(URLAsRegex(url), `$1${dataUrl}$3`);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${getEscapedString(url)})(['\"]?\\\\))`, 'g');\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/ProcessSources.web.ts"],"names":[],"mappings":"AAAA,SACE,SADF,EAEE,qBAFF,EAGE,gBAHF,EAIE,UAJF,EAKE,uBALF,EAME,eANF,QAOO,aAPP;AASA,MAAM,SAAS,GAAG,6BAAlB;AAEA,OAAM,SAAU,aAAV,CAAwB,MAAxB,EAAsC;AAC1C,MAAI,CAAC,MAAM,CAAC,MAAZ,EAAoB;AAClB,WAAO,KAAP;AACD;;AACD,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,MAA6B,CAAC,CAArC;AACD;AAED,OAAO,eAAe,2BAAf,CACL,MADK,EAEL,OAFK,EAGL,GAHK,EAGD;AAEJ,MAAI,CAAC,aAAa,CAAC,MAAD,CAAlB,EAA4B;AAC1B,WAAO,MAAP;AACD;;AAED,QAAM,IAAI,GAAG,QAAQ,CAAC,MAAD,CAArB;AAEA,MAAI,IAAI,GAAG,OAAO,CAAC,OAAR,CAAgB,MAAhB,CAAX;;AACA,OAAK,MAAM,GAAX,IAAkB,IAAlB,EAAwB;AACtB,IAAA,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,IAAI,eAAe,CAAC,MAAD,EAAS,GAAT,EAAc,OAAd,EAAuB,GAAvB,CAAnC,CAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAAS,QAAT,CAAkB,IAAlB,EAA8B;AAC5B,QAAM,MAAM,GAAe,EAA3B;AACA,MAAI,KAAJ;;AACA,SAAO,CAAC,KAAK,GAAG,SAAS,CAAC,IAAV,CAAe,IAAf,CAAT,MAAmC,IAA1C,EAAgD;AAC9C,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,CAAD,CAAjB;AACD;;AACD,SAAO,MAAM,CAAC,MAAP,CAAc,GAAG,IAAI,CAAC,SAAS,CAAC,GAAD,CAA/B,CAAP;AACD;;AAID,eAAe,eAAf,CACE,MADF,EAEE,GAFF,EAGE,OAAA,GAA8B,SAHhC,EAIE,cAAA,GAAgC,uBAJlC,EAIyD;AAEvD,QAAM,QAAQ,GAAG,OAAO,GAAG,UAAU,CAAC,GAAD,EAAM,OAAN,CAAb,GAA8B,GAAtD;AACA,QAAM,IAAI,GAAG,MAAM,cAAc,CAAC,QAAD,CAAjC;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,IAAD,EAAO,qBAAqB,CAAC,GAAD,CAA5B,CAA/B;AAEA,SAAO,MAAM,CAAC,OAAP,CAAe,UAAU,CAAC,GAAD,CAAzB,EAAgC,KAAK,OAAO,IAA5C,CAAP;AACD;;AAED,SAAS,UAAT,CAAoB,GAApB,EAAuB;AACrB,SAAO,IAAI,MAAJ,CAAW,iBAAiB,gBAAgB,CAAC,GAAD,CAAK,aAAjD,EAAgE,GAAhE,CAAP;AACD","sourcesContent":["import {\n  isDataUrl,\n  getMimeTypeFromSource,\n  getEscapedString,\n  resolveUrl,\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n} from './Utils.web';\n\nconst URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\nexport function shouldProcess(string: string): boolean {\n  if (!string.search) {\n    return false;\n  }\n  return string.search(URL_REGEX) !== -1;\n}\n\nexport async function batchProcessAllSourcesAsync(\n  string: string,\n  baseUrl?: string,\n  get?\n): Promise<string> {\n  if (!shouldProcess(string)) {\n    return string;\n  }\n\n  const urls = readURLs(string);\n\n  let done = Promise.resolve(string);\n  for (const url of urls) {\n    done = done.then(string => processURLAsync(string, url, baseUrl, get));\n  }\n  return done;\n}\n\nfunction readURLs(urls: string): Array<any> {\n  const result: Array<any> = [];\n  let match;\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n  return result.filter(url => !isDataUrl(url));\n}\n\ntype SourceHandler = (value: string) => Promise<string>;\n\nasync function processURLAsync(\n  string: string,\n  url: string,\n  baseUrl: string | undefined = undefined,\n  getSourceAsync: SourceHandler = getSourceAndEncodeAsync\n): Promise<string> {\n  const finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n  const data = await getSourceAsync(finalURL);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n\n  return string.replace(URLAsRegex(url), `$1${dataUrl}$3`);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${getEscapedString(url)})(['\"]?\\\\))`, 'g');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}