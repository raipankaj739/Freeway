{"ast":null,"code":"function parseExtension(url) {\n  const match = /\\.([^\\.\\/]*?)$/g.exec(url);\n\n  if (match) {\n    return match[1].toLowerCase();\n  }\n\n  return '';\n}\n\nconst WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst MIME_TYPES = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  otf: 'application/font-opentype',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml'\n};\nexport function getMimeTypeFromSource(url) {\n  const extension = parseExtension(url);\n\n  if (extension in MIME_TYPES) {\n    return MIME_TYPES[extension];\n  }\n\n  throw new Error(`No valid MIME type (${extension}) for url: ${url}`);\n}\nexport function isDataUrl(url) {\n  return url.search(/^(data:)/) !== -1;\n}\n\nfunction getBlobFromCanvasElement(canvas) {\n  const binaryString = window.atob(canvas.toDataURL().split(',')[1]);\n  const length = binaryString.length;\n  const binaryArray = new Uint8Array(length);\n\n  for (let i = 0; i < length; i++) {\n    binaryArray[i] = binaryString.charCodeAt(i);\n  }\n\n  return new Blob([binaryArray], {\n    type: 'image/png'\n  });\n}\n\nexport async function getBlobFromCanvasAsync(canvas, quality) {\n  if (canvas.toBlob) {\n    return new Promise((resolve, reject) => {\n      canvas.toBlob(blob => {\n        if (blob == null) {\n          reject('Failed to convert canvas to blob!');\n        } else {\n          resolve(blob);\n        }\n      }, '2d', quality);\n    });\n  }\n\n  return getBlobFromCanvasElement(canvas);\n}\nexport function resolveUrl(url, baseUrl) {\n  const doc = document.implementation.createHTMLDocument();\n  const base = doc.createElement('base');\n  doc.head.appendChild(base);\n  const a = doc.createElement('a');\n  doc.body.appendChild(a);\n  base.href = baseUrl;\n  a.href = url;\n  return a.href;\n}\nexport function getImageElementFromURIAsync(uri) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n\n    image.onload = () => {\n      resolve(image);\n    };\n\n    image.onerror = () => {\n      reject(`Image could not be loaded ${image.src}`);\n    };\n\n    image.src = uri;\n  });\n}\nexport function getSourceAndEncodeAsync(url, preventCaching = false, missingImageSource = undefined) {\n  const TIMEOUT = 30000;\n\n  if (preventCaching) {\n    // Cache bypass so we dont have CORS issues with cached images\n    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    url += (/\\?/.test(url) ? '&' : '?') + Date.now();\n  }\n\n  return new Promise(resolve => {\n    const request = new XMLHttpRequest();\n    request.onreadystatechange = done;\n    request.ontimeout = timeout;\n    request.responseType = 'blob';\n    request.timeout = TIMEOUT;\n    request.open('GET', url, true);\n    request.send();\n    let placeholder;\n\n    if (missingImageSource) {\n      const split = missingImageSource.split(/,/);\n\n      if (split && split[1]) {\n        placeholder = split[1];\n      }\n    }\n\n    function done() {\n      if (request.readyState !== 4) {\n        return;\n      }\n\n      if (request.status !== 200) {\n        if (placeholder) {\n          resolve(placeholder);\n        } else {\n          fail(`cannot fetch resource: ${url}, status: ${request.status}`);\n        }\n\n        return;\n      }\n\n      const encoder = new FileReader();\n\n      encoder.onloadend = () => {\n        const {\n          result\n        } = encoder;\n\n        if (typeof result === 'string') {\n          const content = result.split(/,/)[1];\n          resolve(content);\n        } else {\n          resolve('');\n        }\n      };\n\n      encoder.readAsDataURL(request.response);\n    }\n\n    function timeout() {\n      if (placeholder) {\n        resolve(placeholder);\n      } else {\n        fail(`timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`);\n      }\n    }\n\n    function fail(message) {\n      throw new Error(message);\n    }\n  });\n}\nexport function formatDataAsUrl(content, type) {\n  return `data:${type};base64,${content}`;\n}\nexport function getEscapedString(string) {\n  return string.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}\nexport function getEscapedXHTMLString(input) {\n  return input.replace(/#/g, '%23').replace(/\\n/g, '%0A');\n}\nexport function getWidthForElement(element) {\n  const rightBorder = getPixelSizeForStyleProperty(element, 'border-right-width');\n  const leftBorder = getPixelSizeForStyleProperty(element, 'border-left-width');\n  return element.scrollWidth + rightBorder + leftBorder;\n}\nexport function getHeightForElement(element) {\n  const bottomBorder = getPixelSizeForStyleProperty(element, 'border-bottom-width');\n  const topBorder = getPixelSizeForStyleProperty(element, 'border-top-width');\n  return element.scrollHeight + bottomBorder + topBorder;\n}\n\nfunction getPixelSizeForStyleProperty(element, styleProperty) {\n  const value = window.getComputedStyle(element).getPropertyValue(styleProperty);\n  return parseFloat(value.replace('px', ''));\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/Utils.web.ts"],"names":[],"mappings":"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","sourcesContent":["function parseExtension(url: string): string {\n  const match = /\\.([^\\.\\/]*?)$/g.exec(url);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n  return '';\n}\n\nconst WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\n\nconst MIME_TYPES = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  otf: 'application/font-opentype',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml',\n};\n\nexport function getMimeTypeFromSource(url: string): string {\n  const extension = parseExtension(url);\n  if (extension in MIME_TYPES) {\n    return MIME_TYPES[extension];\n  }\n  throw new Error(`No valid MIME type (${extension}) for url: ${url}`);\n}\n\nexport function isDataUrl(url: string): boolean {\n  return url.search(/^(data:)/) !== -1;\n}\n\nfunction getBlobFromCanvasElement(canvas: HTMLCanvasElement): Blob {\n  const binaryString = window.atob(canvas.toDataURL().split(',')[1]);\n  const length = binaryString.length;\n  const binaryArray = new Uint8Array(length);\n\n  for (let i = 0; i < length; i++) {\n    binaryArray[i] = binaryString.charCodeAt(i);\n  }\n\n  return new Blob([binaryArray], {\n    type: 'image/png',\n  });\n}\n\nexport async function getBlobFromCanvasAsync(\n  canvas: HTMLCanvasElement,\n  quality?: number\n): Promise<Blob> {\n  if (canvas.toBlob) {\n    return new Promise((resolve, reject) => {\n      canvas.toBlob(\n        blob => {\n          if (blob == null) {\n            reject('Failed to convert canvas to blob!');\n          } else {\n            resolve(blob);\n          }\n        },\n        '2d',\n        quality\n      );\n    });\n  }\n  return getBlobFromCanvasElement(canvas);\n}\n\nexport function resolveUrl(url: string, baseUrl: string): string {\n  const doc = document.implementation.createHTMLDocument();\n  const base = doc.createElement('base');\n  doc.head.appendChild(base);\n  const a = doc.createElement('a');\n  doc.body.appendChild(a);\n  base.href = baseUrl;\n  a.href = url;\n  return a.href;\n}\n\nexport function getImageElementFromURIAsync(uri: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = () => {\n      reject(`Image could not be loaded ${image.src}`);\n    };\n    image.src = uri;\n  });\n}\n\nexport function getSourceAndEncodeAsync(\n  url: string,\n  preventCaching: boolean = false,\n  missingImageSource: string | undefined = undefined\n): Promise<string> {\n  const TIMEOUT = 30000;\n  if (preventCaching) {\n    // Cache bypass so we dont have CORS issues with cached images\n    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    url += (/\\?/.test(url) ? '&' : '?') + Date.now();\n  }\n\n  return new Promise(resolve => {\n    const request = new XMLHttpRequest();\n\n    request.onreadystatechange = done;\n    request.ontimeout = timeout;\n    request.responseType = 'blob';\n    request.timeout = TIMEOUT;\n    request.open('GET', url, true);\n    request.send();\n\n    let placeholder;\n    if (missingImageSource) {\n      const split = missingImageSource.split(/,/);\n      if (split && split[1]) {\n        placeholder = split[1];\n      }\n    }\n\n    function done() {\n      if (request.readyState !== 4) {\n        return;\n      }\n\n      if (request.status !== 200) {\n        if (placeholder) {\n          resolve(placeholder);\n        } else {\n          fail(`cannot fetch resource: ${url}, status: ${request.status}`);\n        }\n\n        return;\n      }\n\n      const encoder = new FileReader();\n\n      encoder.onloadend = () => {\n        const { result } = encoder;\n        if (typeof result === 'string') {\n          const content = result.split(/,/)[1];\n          resolve(content);\n        } else {\n          resolve('');\n        }\n      };\n      encoder.readAsDataURL(request.response);\n    }\n\n    function timeout(): void {\n      if (placeholder) {\n        resolve(placeholder);\n      } else {\n        fail(`timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`);\n      }\n    }\n\n    function fail(message: string): void {\n      throw new Error(message);\n    }\n  });\n}\n\nexport function formatDataAsUrl(content: string, type: string): string {\n  return `data:${type};base64,${content}`;\n}\n\nexport function getEscapedString(string: string): string {\n  return string.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport function getEscapedXHTMLString(input: string): string {\n  return input.replace(/#/g, '%23').replace(/\\n/g, '%0A');\n}\n\nexport function getWidthForElement(element: Element): number {\n  const rightBorder = getPixelSizeForStyleProperty(element, 'border-right-width');\n  const leftBorder = getPixelSizeForStyleProperty(element, 'border-left-width');\n  return element.scrollWidth + rightBorder + leftBorder;\n}\n\nexport function getHeightForElement(element: Element): number {\n  const bottomBorder = getPixelSizeForStyleProperty(element, 'border-bottom-width');\n  const topBorder = getPixelSizeForStyleProperty(element, 'border-top-width');\n  return element.scrollHeight + bottomBorder + topBorder;\n}\n\nfunction getPixelSizeForStyleProperty(element: Element, styleProperty: string): number {\n  const value = window.getComputedStyle(element).getPropertyValue(styleProperty);\n  return parseFloat(value.replace('px', ''));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}