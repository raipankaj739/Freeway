{"ast":null,"code":"import * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\nconst {\n  ExpoBackgroundFetch\n} = NativeModulesProxy;\nvar BackgroundFetchResult;\n\n(function (BackgroundFetchResult) {\n  BackgroundFetchResult[BackgroundFetchResult[\"NoData\"] = 1] = \"NoData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"NewData\"] = 2] = \"NewData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"Failed\"] = 3] = \"Failed\";\n})(BackgroundFetchResult || (BackgroundFetchResult = {}));\n\nvar BackgroundFetchStatus;\n\n(function (BackgroundFetchStatus) {\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Denied\"] = 1] = \"Denied\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Restricted\"] = 2] = \"Restricted\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Available\"] = 3] = \"Available\";\n})(BackgroundFetchStatus || (BackgroundFetchStatus = {}));\n\nexport async function getStatusAsync() {\n  if (Platform.OS !== 'ios') {\n    return BackgroundFetchStatus.Available;\n  }\n\n  return ExpoBackgroundFetch.getStatusAsync();\n}\nexport async function setMinimumIntervalAsync(minimumInterval) {\n  if (Platform.OS !== 'ios') {\n    return;\n  }\n\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\nexport async function registerTaskAsync(taskName, options = {}) {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n  }\n\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(`Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`);\n  }\n\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\nexport async function unregisterTaskAsync(taskName) {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n  }\n\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };","map":{"version":3,"sources":["../src/BackgroundFetch.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,WAAZ,MAA6B,mBAA7B;AACA,SAAS,mBAAT,QAAoC,kBAApC;AACA,SAAS,QAAT,EAAmB,kBAAnB,QAA6C,kBAA7C;AAEA,MAAM;AAAE,EAAA;AAAF,IAA0B,kBAAhC;AAEA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACD,CAJD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAMA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACD,CAJD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAYA,OAAO,eAAe,cAAf,GAA6B;AAClC,MAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAO,qBAAqB,CAAC,SAA7B;AACD;;AACD,SAAO,mBAAmB,CAAC,cAApB,EAAP;AACD;AAED,OAAO,eAAe,uBAAf,CAAuC,eAAvC,EAA8D;AACnE,MAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB;AACD;;AACD,QAAM,mBAAmB,CAAC,uBAApB,CAA4C,eAA5C,CAAN;AACD;AAED,OAAO,eAAe,iBAAf,CAAiC,QAAjC,EAAmD,OAAA,GAAkC,EAArF,EAAuF;AAC5F,MAAI,CAAC,mBAAmB,CAAC,iBAAzB,EAA4C;AAC1C,UAAM,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,mBAA3C,CAAN;AACD;;AACD,MAAI,CAAC,WAAW,CAAC,aAAZ,CAA0B,QAA1B,CAAL,EAA0C;AACxC,UAAM,IAAI,KAAJ,CACJ,SAAS,QAAQ,2FADb,CAAN;AAGD;;AACD,QAAM,mBAAmB,CAAC,iBAApB,CAAsC,QAAtC,EAAgD,OAAhD,CAAN;AACD;AAED,OAAO,eAAe,mBAAf,CAAmC,QAAnC,EAAmD;AACxD,MAAI,CAAC,mBAAmB,CAAC,mBAAzB,EAA8C;AAC5C,UAAM,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,qBAA3C,CAAN;AACD;;AACD,QAAM,mBAAmB,CAAC,mBAApB,CAAwC,QAAxC,CAAN;AACD;AAED,SACE,qBAAqB,IAAI,MAD3B,EAEE,qBAAqB,IAAI,MAF3B","sourcesContent":["import * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\n\nconst { ExpoBackgroundFetch } = NativeModulesProxy;\n\nenum BackgroundFetchResult {\n  NoData = 1,\n  NewData = 2,\n  Failed = 3,\n}\n\nenum BackgroundFetchStatus {\n  Denied = 1,\n  Restricted = 2,\n  Available = 3,\n}\n\ninterface BackgroundFetchOptions {\n  minimumInterval?: number;\n  stopOnTerminate?: boolean;\n  startOnBoot?: boolean;\n}\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS !== 'ios') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (Platform.OS !== 'ios') {\n    return;\n  }\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(taskName: string, options: BackgroundFetchOptions = {}): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync')\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync')\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport {\n  BackgroundFetchResult as Result,\n  BackgroundFetchStatus as Status,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}